%%%%%%%%%%%%%%%%%%%% author.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample root file for your "contribution" to a proceedings volume
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%% Springer %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass{svproc}
\usepackage{url}
\def\UrlFont{\rmfamily}

% Bibliography
\usepackage{biblatex}
\addbibresource{references.bib}

% Math
\usepackage{physics}
\usepackage{siunitx}
\sisetup{output-exponent-marker=\ensuremath{\mathrm{e}}}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

% Optimization and Algorithms
\usepackage{optidef}
\usepackage{algorithmicx}
\usepackage{algorithm,algpseudocode}

% Formatting
\usepackage{xcolor}
\usepackage{bm}  % for bold symbols 
\usepackage{booktabs}  % better tables
\usepackage{pifont}  % for x mark
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{wrapfig}
\usepackage{graphicx}

% Plotting
\usepackage{pgfplots}
\pgfplotsset{compat=1.15,
	legend style={font=\footnotesize},
}
\usepackage{tikzscale}

% Custom commands
\newcommand{\half}{\frac{1}{2}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{S}^3}
\newcommand{\skewmat}[1]{[#1]^\times}

\newcommand{\rmap}{\varphi}
\newcommand{\invrmap}{\varphi^{-1}}

\newcommand{\dR}{\delta \mathcal{R}}
\newcommand{\rot}{ \mathcal{R} }
\newcommand{\dq}{\delta q}
\newcommand{\q}{\textbf{q}}
\newcommand{\eq}{_\text{eq}}
\newcommand{\traj}[2][N]{#2_{0:{#1}}}
\newcommand{\pass}{{\color{green} \checkmark}}
\newcommand{\fail}{{\color{red} \ding{55}}}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BEGIN DOCUMENT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{document}
\mainmatter              % start of a contribution

\title{Planning and Control with Attitude}
\author{Brian Jackson \and Zachary Manchester}

\authorrunning{Jackson and Manchester}
\institute{Stanford University, 496 Lomita Mall, Stanford, CA, USA,\\
\email{\{bjack205,zacm\}@stanford.edu}}

\maketitle

\begin{abstract}
Planning and controlling trajectories for floating-base robotic systems that experience large attitude changes is challenging due to the nontrivial group structure of 3D rotations. 
This paper introduces an accessible and unified approach for tracking control and optimization-based planning on the space of rotations based on vector calculus and linear algebra. The methodology is used to derive an extension of the Linear-Quadratic Regulator (LQR) to systems with arbitrary attitudes, which we call Multiplicative LQR (MLQR). 
We compare MLQR to a state-of-the-art geometric tracking controller designed specifically for quadrotors and demonstrate superior tracking and robustness. 
An iterative variant of MLQR is compared to existing methods on useveral constrained trajectory optimization problems, again demonstrating improved runtime performance. %to optimize trajectories for a variety of robotic systems, we provide benchmark comparisons between several of the most common attitude representations used for motion planning and control and find that the combination of unit quaternion state variables with Rodrigues parameters to represent attitude errors provides an excellent combination of performance and algorithmic simplicity. 
\keywords{motion planning and control, quaternions, optimal control, linear quadratic regulator}
\end{abstract}

\section{Introduction}
    Many useful robotic systems---including quadrotors, airplanes, satellites, autonomous underwater vehicles, and quadrupeds---can perform arbitrarily large three-dimensional translations and rotations as part of their normal operation. 
    While representing translations is straightforward and intuitive, effectively representing the nontrivial group structure of 3D rotations has been a topic of study for many decades. Although we can intuitively deduce that rotations are three-dimensional, a globally non-singular three-parameter representation of the space of rotations does not exist \cite{stuelpnagel1964parametrization}. As a result, when parameterizing rotations, we must either a) pick a three-parameter representation and deal with discontinuities, or b) pick a higher-dimensional representation and deal with constraints between the parameters. While simply representing attitude is nontrivial, generating and tracking motion plans for floating-base systems is an even more challenging problem.
    
    Early work on control problems involving the rotation group dates back to the 1970s, with extensions of linear control theory to spheres \cite{Brockett1973} and $SO(3)$ \cite{Baillieul1978}. Effective attitude tracking controllers have been developed for satellites \cite{wie1985quaternion}, quadrotors \cite{Fresk2013,Liu2015,lee2010geometric,Johnson2005,watterson2020control,mellinger2011minimum}, and a 3D inverted pendulum \cite{Chaturvedi2009}  using various methods for calculating three-parameter attitude errors. 
    
    More recently, these ideas have been extended to trajectory generation \cite{Zefran1998}, sample-based motion planning \cite{Zefran1999,Kuffner2004}, and optimal control. Approaches to optimal control on attitude problems include analytical methods applied to satellites \cite{Spindler1998}, discrete mechanics \cite{Kobilarov2011,Kobilarov2014,Lee2008}, a combination of sampling-based planning and constrained trajectory optimization for satellite formations \cite{Garcia2005, Aoude2008}, projection operators \cite{Saccon2013}, or more general theory for optimization on manifolds \cites{watterson2018trajectory}. Nearly all of these methods rely heavily on principles from differential geometry and Lie group theory; however, despite these works, many recent papers in the robotics community continue to apply traditional methods for motion planning and control with no regard for the group structure of rigid body motion \cite{Alothman2016,deCrousaz2015,Williams2017,Geisert2016}.
    
    In this paper, we make a departure from previous approaches to geometric planning and control that rely heavily on ideas and notation from differential geometry, and instead use only basic mathematical tools from linear algebra and calculus that should be familiar to most roboticists. Similar to \cite{Mandic2011,Xu2016}, in Sec. \ref{sec:Quaternion_Calculus} we introduce a quaternion differential calculus, but take a significantly simpler and more general approach that unifies both planning and control, enabling straight-forward adaptation of existing algorithms to systems with quaternion states. To make this concrete, in Sec. \ref{sec:MLQR} we apply our approach to derive an extension to the linear-quadratic regulator (LQR) that we call multiplicative LQR (MLQR), which is the control dual to the multiplicative extended Kalman filter (MEKF) from the state estimation literature \cite{markley2014fundamentals}. In Sec. \ref{sec:experiments} we provide several simulation results demonstrating the application of our method to tracking control and constrained trajectory optimization.
    In summary, our contributions include:
    %\vspace{-10pt}
    \begin{itemize}
        \item A unified approach to quaternion differential calculus entirely based on standard vector calculus and linear algebraic operations
        \item Derivation of multiplicative LQR, an adaptation of LQR to the control of systems with quaternion states
        \item A set of benchmark motion-planning and trajectory-tracking problems in which we compare our approach to existing methods commonly used in the robotics community to account for 3D rotations
    \end{itemize}


\section{Background}
    We begin by defining some useful conventions and notation. Attitude is defined as the rotation from the robot's body frame to a global inertial frame. We also define gradients to be row vectors, that is, for $f(x) : \R^n \to \R$, $\pdv{f}{x} \in \R^{1\times n}$.
    
    \subsection{Unit Quaternions} \label{sec:quaternions}
        We leverage the fact that quaternions are linear operators and that the space of quaternions $\mathbb{H}$ is isomorphic to $\R^4$ to explicitly represent---following the Hamilton convention---a quaternion $\q \in \mathbb{H}$ as a standard vector $q \in \R^4 := [q_s \;\; q_v^T]^T$ where $q_s \in \R$ and $q_v \in \R^3$ are the scalar and vector part of the quaternion, respectively.
        
        Quaternion multiplication is defined as
        \begin{equation} \label{eq:quat_mult}
            \q_2 \otimes \q_1 = L(q_2) q_1 = R(q_1) q_2
        \end{equation}
        where $L(q)$ and $R(q)$ are orthonormal matrices defined as
        \begin{align}
            L(q) &:= \begin{bmatrix} q_s \;\; & -q_v^T \\ q_v \;\; & q_s I + \skewmat{q_v} \end{bmatrix} 
            \label{eq:Lmult} \\
            %= \begin{bmatrix} q & G(q) \end{bmatrix} \label{eq:Lmult} \\
            R(q) &:=\begin{bmatrix} q_s \;\; & -q_v^T \\ q_v \;\; & q_s I - \skewmat{q_v} \end{bmatrix} \label{eq:Rmult},
        \end{align}
        and $\skewmat{x}$ is the skew-symmetric matrix operator
        \begin{equation}
            \skewmat{x} := \begin{bmatrix} 0 & -x_3 & x_2 \\ x_3 & 0 & -x_1\\ -x_2 & x_1 & 0 \end{bmatrix}.
        \end{equation}
        
        The inverse of a unit quaternion $q^{-1}$, giving the opposite rotation, is equal to its conjugate $q^*$, which is simply the same quaternion with a negated vector part:
        \begin{equation} \label{eq:T}
            \q^* = T q := \begin{bmatrix} 1 & \\ & -I_3 \end{bmatrix} q
        \end{equation}
        The following identities, which are easily derived from \eqref{eq:Lmult}--\eqref{eq:T}, are extremely useful:
        \begin{align}
            &L(Tq) = L(q)^T = L(q)^{-1} \\
            &R(Tq) = R(q)^T = R(q)^{-1} .
        \end{align}
        
        We will sometimes find it helpful to create a quaternion with zero scalar part from a vector $r \in \R^3$. We denote this operation as,
        \begin{equation}
            \hat{r} = H r \equiv \begin{bmatrix} 0 \\ I_3 \end{bmatrix} r.
        \end{equation}
        Unit quaternions rotate a vector through the operation $\hat{r}' = \q \otimes \hat{r} \otimes \q^*$. This can be equivalently expressed using matrix multiplication as
        \begin{align} 
            r' &= H^T L(q) R(q)^T H r = A(q)r , \label{eq:quaternion_rotation} %\\ 
               %&= H^T L(q) L(Hr) T q = H^T R(Hr) R(q)^T q %\label{eq:quaternion_rotation2}
        \end{align}
        where $A(q)$ is the rotation matrix in terms of the elements of the quaternion \cite{markley2014fundamentals}. 
    
    % \todo{Merge 3.1 and 3.2. Start with unit quaternions (maybe put some of the section 4 material here), then define RPs and MRPs with the simple equations relating them to the quaternion. Keep it high level and cite references for details.}

    % \subsection{Rodrigues Parameters}
    %     Rodrigues parameters, also known as Gibbs vectors or the Cayley transformation of quaternion, are a computationally-efficient 3-parameter represention of rotations, obtained by projecting onto the plane tangent to the quaternion identity.
    %     Their definition (up to the scaling factor) is given in Table \ref{tab:retraction_maps} as the Cayley Map. 
    %     Unlike quaternions and MRPs, they do not have a sign ambiguity.
        
    %  \subsection{Modified Rodrigues Parameters}
    %     Modified Rodrigues Parameters (MRPs) are the newest parameter representation and can be considered a stereographic projection of the quaternion. 
    %     They are defined (up to the scaling factor) in Table \ref{tab:retraction_maps}. 
    %     MRPs have gained a lot of attention in the aerospace community since their singularity happens at \ang{360} and are a minimal 3-parameter representation. 
    %     %\cite{markley2014fundamentals} is an excellent resource for gaining further understanding of both Rodrigues parameters and MRPs. While predominantly only seen in the aerospace community, MRPs have recently been introduced to other fields such as computer graphics \cite{Terzakis2018}.
        
    \subsection{Rigid Body Dynamics} \label{sec:rigidbody_dynamics}
        In the current work we will restrict our focus to rigid bodies moving freely in 3D space. That is, we consider systems with dynamics of the following form:
        \begin{equation} \label{eq:rigid_body_dynamics}
            x = \begin{bmatrix} r \\ R \\ v \\ \omega \end{bmatrix}, \quad 
            \dot{x} = \begin{bmatrix} 
                v \\ 
                \texttt{kinematics}(R,\omega) \\ 
                \frac{1}{m} F_G(x,u) \\ 
                J^{-1}(\tau_L(x,u) - \omega \times J \omega) 
            \end{bmatrix}
        \end{equation}
        where $x$ and $u$ are the state and control vectors, $r \in \R^3$ is the position, $R \in SO(3)$ is the attitude, $v \in \R^3$ is the linear velocity, and $\omega \in \R^3$ is the angular velocity. $m \in \R$ is the mass, $J \in \R^{3\times3}$ is the inertia matrix, $F_G(x,u) \in \R^3$ are the forces in the global frame, $\tau_L(x,u)$ are the moments in the local (body) frame, and $\texttt{kinematics}$ are the kinematics for the chosen attitude representation. The kinematics for unit quaternions are
        \begin{equation}
            \dot{q} = \half \q \otimes \hat{\omega} = \half L(q) H \omega.
        \end{equation}
    %     \todo{Get rid of this table. Give the kinematics for each representation in line with its description above. Skip what you can and cite.}
    %     \begin{table}
    % 		\centering
    % 		\caption{Attitude Representations}
    % 		\begin{tabular}{lll}
    % 			\toprule
    % 			\textbf{Name} & \textbf{Kinematics} & \textbf{Singularity} \\
    % 			\midrule
    % 			Rotation Matrix & $R \skewmat{\omega_L}$ & None \\
    % 			Quaternions & $\half q \hat{\omega_L}$ & None \\
    % 			Euler Angles & see \cite{michael2010grasp} & $\theta \text{ (pitch)} = \ang{90}$ \\
    % 		    Rodrigues Param & $\half(I_3 + \skewmat{g} + g g^T) \omega$ & $\ang{180}$ \\
    % 		    MRP & $\frac{1+\norm{p}^2}{4}\left(I_3 + 2\frac{(\skewmat{p})^2 + \skewmat{p}}{1+\norm{p}^2}\right)\omega_L$ & \ang{360} \\
    % 			\toprule
    % 		\end{tabular}
    % 		\label{tab:attitude_kinematics}
    % 	\end{table} 
        
        
    % \subsection{Trajectory Optimization}
    % \todo{I would try to get rid of this section}
    %     Trajectory optimization is a powerful framework for controlling complicated robotic systems. The value of trajectory optimization lies primarily in its generality, allowing it to be applied to a very broad class of dynamical systems. One of the objectives of this paper is to present a clear and performant method for solving trajectory optimization problems for rigid body motions, i.e. $SE(3)$. Trajectory optimization methods solve some variant of the following problem:
    %     \begin{mini}[3]
    %     	{x_{0:N},u_{0:N-1}}{\ell_N(x_N) + \sum_{k=0}^{N-1} \ell_k(x_k,u_k,\Delta t) }{}{}
    %     	\addConstraint{x_{k+1}}{=f(x_k,u_k,\Delta t), \; k = 1,...,N\text-1}
    %     	\addConstraint{g_k(x_k,u_k)}{\leq 0,\; \forall k}
    %     	\addConstraint{h_k(x_k,u_k)}{=0,\; \forall k}
    %     	\label{opt:discrete_trajopt},
    %     \end{mini}
    %     where $x_k \in \R^n, u_k \in \R^m$ are the state and control values at time step $k$, $N$ is the total number of knot points, $\ell_k$ is the stage cost function, $\ell_N$ is the terminal cost, and $f(x,u,\Delta t)$ are the discretized dynamics with step length $\Delta t$.
        
    %     There are many methods for solving trajectory optimization problems. Iterative LQR (iLQR) is a common method that has gain a lot of attention in recent years, mainly for it's speed and relative simplicity \cite{li2004iterative}. In the current work, we extend our implementation as part of the ALTRO solver detailed in \cite{howell2019altro}.
        

\section{Quaternion Differential Calculus} \label{sec:Quaternion_Calculus}
    We now present a simple but powerful method for taking derivatives of functions involving quaternions based on the notation and linear algebraic operations outlined in Sec. \ref{sec:quaternions}.
    
    \begin{figure}
        \centering
        % \includegraphics[height=6cm]{figures/tangent_plane.png}
        \includegraphics[height=5cm]{figures/tangent_plane.tikz}
        \caption{When linearizing about a point $q$ on an sphere $\mathbb{S}^{n-1}$ in n-dimensional space, the tangent space $T$ is a plane living in $\R^{n-1}$, illustrated here with $n=3$. Therefore, when linearizing about a unit quaternion $q \in \Q$, the space of differential rotations lives in $\R^3$.}
        \label{fig:tangent_plane}
    \end{figure}
        
        Derivatives consider the effect an infinitesimal perturbation to the input has on an infinitesimal perturbation to the output. For vector spaces, the composition of the perturbation with the nominal value is simple addition and the infinitesimal perturbation lives in the same space as the original vector. For unit quaternions, however, neither of these are true; instead, they compose according to \eqref{eq:quat_mult}, and infinitesimal unit quaternions are (to first order) confined to a 3-dimensional plane tangent to $\Q$ (see Fig. \ref{fig:tangent_plane}).
        %, and are related through a non-linear mapping $\varphi : \R^3 \to \Q$ )
        The fact that differential unit quaternions are three-dimensional should make intuitive sense: Rotations are inherently three-dimensional and differential rotations should live in the same space as angular velocity, i.e. $\R^3$. 
        
        There are many possible three-parameter representations for small rotations in the literature. Many authors use the exponential map \cite{Baillieul1978,Zefran1998,Lee2008,Saccon2013,Sola2017,Fan2016,watterson2018trajectory}, while others have used the Cayley map (also known as Rodrigues parameters) \cite{Kobilarov2011,Kobilarov2014}, Modified Rodrigues Parameters (MRPs) \cite{Terzakis2018}, or the vector part of the quaternion \cite{Fresk2013}. 
        We choose Rodrigues parameters \cite{markley2014fundamentals} because they are computationally efficient and do not inherit the sign ambiguity associated with unit quaternions. The mapping between a vector of Rodrigues parameters $\phi \in \R^3$ and a unit quaternion $q$ is known as the Cayley map:
        \begin{equation} \label{eq:cayley}
            q = \varphi(\phi) = \frac{1}{\sqrt{1 + \norm{\phi}^2}} \begin{bmatrix} 1 \\ \phi \end{bmatrix}.
        \end{equation}
        We will also make use of the inverse Cayley map:
        \begin{equation}
            \phi = \varphi^{-1}(q) = \frac{q_v}{q_s}.
        \end{equation}
        
    \subsection{Jacobian of Vector-Valued Functions}
        When taking derivatives with respect to quaternions, we must take into account both the composition rule and the nonlinear
        mapping between the space of unit quaternions and our chosen three-parameter error representation. 
        % Before demonstrating how this is done, let's consider the real-valued case we should already be familiar with. For some function $y = r(x) : \R^n \to \R^p$ with a differential value $\delta x \in \R^n$ applied to the input:
        % \begin{align}
        %     y + \delta y = r(x+\delta x) &\approx r(x) + \nabla r(x) \delta x,
        %     % &= \lim_{\delta x \to 0} x + \pdv{r}{x} \pdv{r + \delta x}{\delta x} = r + \pdv{r}{x} 
        % \end{align}
        % we calculate $\nabla r$ by taking the derivative with respect $\delta x$, as $\delta x$ approaches zero:
        % \begin{equation}
        %     \nabla r(x) = \lim_{\delta x \to 0} \pdv{r}{x} \pdv{(x + \delta x)}{\delta x} = \lim_{\delta x \to 0} \pdv{r}{x} I = \pdv{r}{x}
        % \end{equation}
        Let $\phi \in \R^3$ be a differential rotation applied to a function with quaternion inputs $y = h(q): \Q \to \R^p$, such that
        \begin{equation} \label{eq:vector_function}
            y + \delta y = h(L(q) \varphi(\phi)) \approx h(q) +  \nabla h(q) \phi.
        \end{equation}
        We can calculate the Jacobian $\nabla h(q) \in \R^{p \times 3}$ by differentiating \eqref{eq:vector_function} with respect to $\phi$, evaluated at $\phi = 0$:
        \begin{equation} \label{eq:quat_gradient}
            \nabla h(q) = \pdv{h}{q} L(q) H := \pdv{h}{q} G(q) = \pdv{h}{q} \begin{bmatrix} -q_v^T \\ sI_3 + \skewmat{q_v} \end{bmatrix}
        \end{equation}
        where $G(q) \in \R^{4 \times 3}$ is the \textit{attitude Jacobian}, which essentially becomes a ``conversion factor'' allowing us to apply results from standard vector calculus to the space of unit quaternions. This form is particularly useful in practice since $\pdv*{h}{q} \in \R^{p \times 4}$ can be obtained using finite difference or automatic differentiation.
        As an aside, although we have used Rodrigues parameters, $G(q)$ is actually the same (up to a constant scaling factor) for any choice of three-parameter attitude representation.
        
    \subsection{Hessian of Scalar-Valued Functions}
	    If the output of $h$ is a scalar ($p = 1$), then we can find its Hessian by taking the Jacobian of \eqref{eq:quat_gradient} with respect to $\phi$ using the product rule, again evaluated at $\phi = 0$:
	   % \begin{equation} \label{eq:hess1}
	   %     \nabla^2 h(q) = \lim_{\phi\to0} \left(L(q) \pdv{\varphi}{q} \right)^T \pdv[2]{h}{q} \left(L(q) \pdv{\varphi}{\phi} \right)+ \pdv{\phi}  \left(G(L(q) \varphi(\phi))^T \pdv{h}{q}^T \right) .
	   % \end{equation}
	   % Expanding the second term in \eqref{eq:hess1} and simplifying results in:
	    \begin{equation} \label{eq:quat_hessian}
            \nabla^2 h(q) = G(q)^T \pdv[2]{h}{q} G(q) + I_3 \pdv{h}{q}q,
	    \end{equation}
	    where the second term comes from the second derivative of $\varphi(\phi)$. Similar to $G(q)$, this ends up being the same (up to a scaling factor) for any choice of three-parameter attitude representation.
	    
    \subsection{Jacobian of Quaternion-Valued Functions}
        We now consider the case of a function that maps unit quaternions to unit quaternions, $q' = f(q) : \Q \to \Q$. Here we must also consider the non-trivial effect of a differential value applied to the output, i.e.:
        \begin{equation} \label{eq:dqoutput}
            L(q') \varphi(\phi') = f(L(q)\varphi(\phi)) .
        \end{equation}
        Solving \eqref{eq:dqoutput} for $\phi'$ we find,
        \begin{equation} \label{eq:phiprime}
            \phi' = \varphi^{-1} \left( L(q')^T f(L(q)\varphi(\phi)) \right) \approx \nabla f(q) \, \phi.
        \end{equation}
        Finally, the desired Jacobian is obtained by taking the derivative of \eqref{eq:phiprime} with respect to $\phi$:
        \begin{equation} \label{eq:quat_jacobian}
            \nabla f(q) = H^T L(q')^T \pdv{f}{q} L(q) H = G(q')^T \pdv{f}{q} G(q).
        \end{equation}
        The leading $G(q')^T$ comes from the fact that as $\phi' \to 0$, $L(q') f(q) \to I_q$, where $I_q$ is the quaternion identity. Differentiating through the inverse map, evaluated at the quaternion identity, we find that $\pdv*{\varphi^{-1}}{q} \to H^T$ for any three-parameter attitude representation.
        
    % \subsection{The Attitude Jacobian}
    %     We now derive the unit quaternion \textit{attitude Jacobian} that maps infinitesimal rotations into changes in the attitude quaternion. Consider the fairly trivial function $g(q,\phi) = L(q) \varphi(\phi)$, which simply composes a small rotation $\phi$ with a nominal attitude $q$, analagous to $x + \delta x$ in a vector space. Taking the derivative with respect to $\phi$ and evaluating it at $\phi=0$, we find the following Jacobian matrix, which we denote $G(q)$:
    %     \begin{equation} \label{eq:differential_jacobian}
    %         \pdv{f}{\phi}\Big|_{\phi=0} = L(q) \pdv{\varphi}{\phi}\Big|_{\phi=0} = L(q) H = \begin{bmatrix} -q_v^T \\ q_s I + \skewmat{q_v} \end{bmatrix} \equiv G(q)
    %     \end{equation}
    %     \todo{I still don't like this...} By differentiating through the inverse of $f$, $f^{-1}(q,q') = \varphi^{-1}(L(q')^T q)$, and evaluating at the unit quaternion identity, we
    %     can similarly find that
    %     \begin{equation}
    %         \pdv{f^{-1}}{q}\Big|_{q=I_q} = H^T L^T(q') = G(q')^T
    %     \end{equation}
    %     The attitude Jacobian essentially becomes a ``conversion factor'' allowing us to apply results from standard vector calculus to the space of unit quaternions. 
    %     As an aside, although we have used Rodrigues parameters, $G(q)$ is actually the same (up to a constant scaling factor) for any choice of three-parameter attitude representation.
        
        % It can also be helpful to consider how changes in the rotation affect the differential rotation, or the \textit{inverse differential Jacobian}. 
    % Consider the simple function $\phi = g(q,q_0) = \varphi^{-1}\left(L(q_0)^T q \right) \iff \varphi^{-1}(\q_0^{-1} \otimes \q)$, similar to $\delta x = x - x_0$ in vector space.
    % Taking the derivative with respect to $q$ we get
    % \begin{equation} \label{eq:inverse_differential_Jacobian}
    %      \pdv{g}{q} = \pdv{\varphi^{-1}\left(L(q_0)^T q \right)}{q} L(q_0)^T
    % \end{equation}
    % In the limit as $\phi \to 0$, $L(q_0)^T q$ approaches the identity unit quaternion, $I_q$. Similar to above, it can be shown that for all the retraction mentioned, $\pdv*{\varphi^{-1}}{q}|_{q=I_q} = H^T$. The inverse differential Jacobian is then simply $H^T L(q_0)^T = G(q_0)^T$.
    %     \begin{table}
    % 		\centering
    % 		\caption{Retraction Maps \todo{I would merge this table into the background section on different attitude descriptions. I would also ditch the ``retraction map'' lingo.}}
    % 		\begin{tabular}{lll}
    % 			\toprule
    % 			\textbf{Name} & \textbf{Definition} & \textbf{Inverse} \\
    % 			\midrule
    % 			Exponential Map & $\exp(\phi)$ & $\log(q)$ \\
    % 			Cayley Map & $\begin{bmatrix} 1 \\ g \end{bmatrix}/\sqrt{1 + \norm{g}^2}$ & $ q_v/q_s$ \\
    % 			MRP Map & $\begin{bmatrix} 1 -  \norm{p/2}^2 \\ 2 (p/2) \end{bmatrix}/(1+\norm{p/2}^2)$ & $2 q_v/(1+q_s)$ \\
    % 		    Vector Map & $\begin{bmatrix} \sqrt{1 -  \norm{\upsilon}^2} \\ \upsilon \end{bmatrix}$	& $q_v$ \\
    % 			\toprule
    % 		\end{tabular}
    % 		\label{tab:retraction_maps}
    % 	\end{table}
    	
% 	\subsection{Jacobians of Vector-Valued Functions}
% 	    We now consider taking derivatives of a function $h(q) : \Q \to \R^p$ that has unit quaternion inputs and scalar or vector outputs. 
% 	    Specifically, we seek the Jacobian that maps an infinitesimal rotation $\phi$ applied to the input into changes in the output $\delta x$:
% 	    \begin{equation}
% 	        x + \delta x = h(L(q)\varphi(\phi)) \approx h(q) + \nabla h(q) \, \phi.
% 	    \end{equation}
% 	    Using the results of the previous section and applying the chain rule we find,
% 	    \begin{equation} \label{eq:quat_gradient}
% 	        \nabla h(q) = \pdv{\phi}\Big|_{\phi=0} \Big( h(L(q) \varphi(\phi)) \Big) = \pdv{h}{q} L(q) H = \pdv{h}{q} G(q) ,
% 	    \end{equation}
% 	    where $\pdv*{h}{q} \in \R^{p\times4}$ is the Jacobian (or gradient if $p=1$) of $h$ with respect to $q$, treating $q$ as a normal vector. This form is particularly useful in practice since $\pdv*{h}{q}$ can be obtained using finite differences or automatic differentiation.
	    
%     \subsection{Hessians of Scalar-Valued Functions}
% 	    If the output of $h$ is a scalar ($p = 1$), then we can find its Hessian by taking the Jacobian of \eqref{eq:quat_gradient}. Using the product rule, we obtain,
% 	    \begin{equation} \label{eq:hess1}
% 	        \nabla^2 h(q) = G(q)^T \pdv[2]{h}{q} G(q) + \pdv{\phi}\bigg|_{\phi=0}  \left(G(L(q) \varphi(\phi))^T \pdv{h}{q}^T \right) .
% 	    \end{equation}
% 	    Expanding the second term in \eqref{eq:hess1} results in:
% 	    \begin{equation} \label{eq:quat_hessian}
% 	            \nabla^2 h(q) = G(q)^T \pdv[2]{h}{q} G(q) + I_3 \pdv{h}{q}q .
% 	    \end{equation}
	    
	   % We obtain the actual gradient / Jacobian and Hessian of $h$ by evaluating \eqref{eq:quat_gradient} and \eqref{eq:quat_hessian} at $\phi = 0$:
	   % \begin{equation}
	   %     \pdv{h}{\phi} = \pdv{h}{q} G(q)
	   % \end{equation}
	   % and for $p = 1$
	   % \begin{equation}
	   %     \pdv[2]{h}{\phi} = G(\q)^T \pdv[2]{h}{q} G(q) + I_3 \pdv{h}{q} q
	   % \end{equation}
	   % where the last term in the Hessian comes from the fact that, for all the differential maps mentioned, $\nabla^2 \varphi(\phi, b)|_{\phi=0} = I_3 b_1$ where $b_1$ is the first element of the input vector $b$. Since $b = L(q)^T \pdv*{h}{q}$, by inspecting \eqref{eq:Lmult} we see $b_1 = q^T \pdv*{h}{q}^T = \pdv*{h}{q} q$.
	    
% 	\subsection{Jacobians of Quaternion-Valued Functions}

%         We now consider the case of a function that maps unit quaternions to unit quaternions, $q' = f(q)$. The key idea is to consider the effect an infinitesimal rotation applied to the input has on an infinitesimal rotation applied to the output:
%         \begin{equation} \label{eq:dqoutput}
%             L(q') \varphi(\phi') = f(L(q)\varphi(\phi)) .
%         \end{equation}
%         %This means we expect the Jacobian of $f$ to be a square $3 \times 3$ matrix. 
%         Solving \eqref{eq:dqoutput} for $\phi'$ we find,
%         \begin{equation} \label{eq:phiprime}
%             \phi' = \varphi^{-1} \left( L(q')^T f(L(q)\varphi(\phi)) \right) \approx \nabla f(q) \, \phi.
%         \end{equation}
%         Finally, the desired Jacobian is obtained by taking the derivative of \eqref{eq:phiprime} with respect to $\phi$:
%         \begin{equation} \label{eq:quat_jacobian}
%             \nabla f(q) = \pdv{\phi'}{\phi}\Big|_{\phi=0} = H^T L(q')^T \pdv{f}{q} L(q) H = G(q')^T \pdv{f}{q} G(q).
%         \end{equation}
        
    % \subsection{Summary of Quaternion Calculus}
    % \todo{get rid of this subsection}
    %     Inspecting \eqref{eq:quat_gradient}, \eqref{eq:quat_hessian} and \eqref{eq:quat_jacobian} we see that the differential Jacobian $G(q)$ effectively ``maps'' the gradients, Hessians, and Jacobians we would obtain by naively treating the quaternion as a vector to the correct differential values that account for the group structure of rotations, along with the one additional piece required in the Hessian \eqref{eq:quat_hessian}. This is nice for a couple reasons: first, we can use standard techniques such as finite-differencing or automatic differentiation to calculate the derivatives we need, and then simply ``convert'' them with a few extra matrix multiplications; secondly, we can easily adapt existing algorithms developed on vector spaces to handle quaternions, such as the extremely useful Linear Quadratic Regulator.


\section{Multiplicative LQR} \label{sec:MLQR}
    Leveraging the methods from the previous section, we derive multiplicative LQR (MLQR), a variant of LQR that correctly accounts for the group structure of rotations. For concreteness, we consider a system with rigid body dynamics, as presented in Sec. \ref{sec:rigidbody_dynamics}, and design a controller to stabilize the system about a dynamically feasible discretized reference trajectory $\bar{x}_{0:N}, \bar{u}_{0:N}$ with $N$ time steps. 
    We begin by linearizing the dynamics about the reference trajectory using \eqref{eq:quat_jacobian}. Our linearized error dynamics become
    \begin{equation} \label{eq:linearized_dynamics}
        \delta x_{k+1} = A_k \delta x_k + B_k \delta u_k 
    \end{equation}
    where \begin{equation}
        A_k = E(\bar{x}_{k+1})^T \pdv{f}{x}|_{\bar{x}_k,\bar{u}_k} E(\bar{x}_k), \quad
        B_k = E(\bar{x}_{k+1})^T \pdv{f}{u}|_{\bar{x}_k,\bar{u}_k},
    \end{equation}
    and $\delta x_k \in \R^{12}$ and $E(x_k) \in \R^{12 \times 13}$ are the state error and state error Jacobian:
    \begin{equation} \label{eq:state_error}
        \delta x_k = \begin{bmatrix} 
            r_k - \bar{r}_k \\ \varphi^{-1}(\bar{\q}_k^{-1} \otimes \q_k) \\ v_k - \bar{v}_k \\ \omega_k - \bar{\omega}_k 
        \end{bmatrix}, \; 
        E(x) = \begin{bmatrix}
            I_3 & & & \\
            & G(q) & & \\
            & & I_3 & \\
            & & & I_3 \\
        \end{bmatrix}.
    \end{equation}
    
    With our linearized system, we can apply the traditional LQR Riccati recursion,
    \begin{equation}
         P_k = W_k +  A_k^T P_{k+1} A_k - A_k^T P_{k+1}^T B_k (R_k + B_k^T P_{k-1} B_k)^{-1} B_k^T P_{k+1} A_k ,
    \end{equation}
    which minimizes the quadratic cost function
    \begin{equation}
        \half \sum_{k=0}^N \delta x_k^T Q_k \delta x_k + \delta u_k^T R_k \delta u_k
    \end{equation}
    of the state \emph{error}, where $Q_k \in \R^{12 \times 12}$ is the weight matrix on the state \emph{error}, and $R_k \in \R^m$ is the weight matrix on the controls. From this, we get our non-linear feedback policy
    \begin{equation} \label{eq:mlqr_control}
        u = K_k \delta x_k + \bar{u}_k.
    \end{equation}
    where $\delta x_k$ is computed online using the non-linear error function \eqref{eq:state_error} and the linear feedback gain $K_k$ is calculated using the standard LQR formula:
    \begin{equation} \label{eq:LQR_gain}
         K_k := -(R_k + B_k^T P_{k+1} B_k)^{-1} B_k^T P_{k+1} A_k.
    \end{equation}
    
    The multiplicative Linear Quadratic Regulator is summarized as follows:
    \begin{enumerate}
        \item Pick $Q_k \in \R^{12 \times 12}$ to weight the state \textit{error}, and $R_k \in \R^{m \times m}$
        \item Linearize the dynamics using the state error Jacobian \eqref{eq:state_error}
        \item Compute $K_k$ using the standard LQR Riccati recursion
        \item Online, compute the control using \eqref{eq:state_error} and \eqref{eq:mlqr_control}.
    \end{enumerate}
    
    % We now wish to find a sequence of controls that minimize a quadratic cost function penalizing deviations from the reference trajectory and large control values, while obeying our system dynamics. This is succinctly stated by the following optimization problem:
    % \begin{mini}[2]
    % 	{x_{0:N},u_{0:N-1}}{\half x_N^T W_N x_N + \half\sum_{k=0}^{N-1} x_k^T W_k x_k + u_k^T R_k u_k }{}{}
    % 	\addConstraint{x_{k+1}}{=A_k x_k + B_k u_k}
    % 	\addConstraint{x_0}{=x_\text{init}}
    % 	\label{opt:discrete_LQR},
    % \end{mini}
    % where we have dropped the $\delta$ leading the states and controls to reduce visual clutter. 
    
    % We now define the \textit{value function} $V_k(x)$ which is simply the cost beginning at time step $k$, such that $V_0(x)$ is the total cost, and $V_N(x) = \half x_N^T W_N x_N$ is the terminal cost. Using the Bellman equation and the principle of optimality, we can define it recursively: %, along with the \textit{action-value function} $Q(x_k,u_k)$:
    % \begin{equation} \label{eq:value_function}
    %     V_k(x) = \min_{u_k} \half x_k^T W_k x_k + \half u_k^T R_k u_k + V_{k+1}(f(x_k,u_k))
    % \end{equation}
    % % \begin{equation} \label{eq:action_value_function}
    % %     V_k(x) = \min_{u_k} Q(x_k,u_k)
    % % \end{equation}
    % By assuming $V_k(x) = \half x_k^T P_k x_k$ for some symmetric positive-definite matrix $P$, we can solve \eqref{eq:value_function} in terms of $P_{k+1}$ using the first-order necessary condition:
    % \begin{equation}
    %     \pdv{Q}{u} = R_k u_k + B^T P_{k+1}(A_k x_k + B_k u_k) = 0
    % \end{equation}
    % Solving for $u_k$ we find the optimal feedback policy: 
    % \begin{equation} \label{eq:LQR_gain}
    %     u_k^* = -(R_k + B_k^T P_{k+1} B_k)^{-1} B_k^T P_{k+1} A_k x_k \equiv -K_k x_k
    % \end{equation}
    % % where $Q_{uu} = \pdv*[2]{Q}{u}$ and $Q_{ux} = \pdv*{Q}{u}{x}$. 
    
    % With an optimal feedback policy, we now substitute \eqref{eq:LQR_gain} into \eqref{eq:value_function}, and after simplifying the the result to a quadratic expression in $x_k$, obtain the recurrence relationship:
    % \begin{equation}
    %      P_k = W_k +  A_k^T P_{k+1} A_k - A_k^T P_{k+1}^T B_k (R_k + B_k^T P_{k-1} B_k)^{-1} B_k^T P_{k+1} A_k.
    % \end{equation}
    % Iterating backwards in time defines the control gains $K \in \R^{m \times 12}$ for each time step. These gains are cached in the controller and looked up online.
    
    % When running the controller online, we compare our current state estimate $\hat{x}$ to our reference state $\bar{x}$ and compute our state differential $\delta x$ using the nonlinear function \eqref{eq:state_error}. The new control value is then computed as
 
    
    \subsection{Constrained Iterative MLQR}
        As demonstrated above, it is very straight-forward to adapt LQR to use quaternions. We similarly use this technique to adapt nonlinear trajectory optimization algorithms. Here we present the modifications to the ALTRO solver \cite{howell2019altro}, which uses iterative LQR (iLQR) combined with an augmented Lagrangian approach to handle constraints. 
        
        For each iteration of iLQR within ALTRO, we can calculate a quadratic approximation of the cost function using \eqref{eq:quat_gradient} and \eqref{eq:quat_hessian}. 
        Identical to \eqref{eq:linearized_dynamics}, we use \eqref{eq:quat_jacobian} to linearize the dynamics and use MLQR to solve for the feedback and feedforward gains. 
        
        The only other modification to the algorithm is during the iLQR ``forward pass'' that simulates the system with the closed-loop MLQR controller, where we use \eqref{eq:state_error} to calculate the nonlinear feedback policy during the forward roll-outs.
        For robustness, we may also add an additional criterion to the line search that checks for singularities in the three-parameter error state which, for the Cayley map, occur at \ang{180}, at which point the step size should be reduced.
        
        % While the core algorithm doesn't change in practice, sometimes the approach used to solve the problem has to be modified, especially with cost functions. Since many cost function penalize distance from some desired state, there are better ways of doing this than naively subtracting two quaternions. The following section describes a few cost functions that are better-suited for this type of task.
    
        % \begin{algorithm}
        % \begin{algorithmic}[1]
        % \caption{iMLQR} \label{alg:iMLQR}
        % \Function{ForwardPass}{$\traj[N-1]{u}$} 
        %     \State $x,u \leftarrow $ simulate the system forward 
        %     \While{not converged}
        %         \State {\color{blue} $W,R,w,r \leftarrow$ Quadratic expansion \eqref{eq:quat_gradient}, \eqref{eq:quat_hessian}}
        %         \State {\color{blue} $A,B \leftarrow$ Linearize dynamics \eqref{eq:linearized_dynamics}}
        %         \State $K,d,\Delta V \leftarrow$ \textproc{LQR}$(W,R,w,r,A,B)$
        %         \State {\color{blue} $x,u \leftarrow$ \textproc{ForwardPass}$(\traj{x},\traj{u},K,d,\Delta V)$}
        %     \EndWhile\\
        %     \Return $X,U,J$
        % \EndFunction
        % \end{algorithmic}
        % \end{algorithm}
        
        % \begin{algorithm}
        % \begin{algorithmic}[1]
        % \caption{Forward Pass} \label{alg:FP}
        % \Function{ForwardPass}{$X,U,K,d,\Delta V,J$} 
        %     \State Initialize $\bar{x}_0 = x_0$, $\alpha = 1$, $J^{\small{-}} \leftarrow J$
        %     \For{k=0:1:N-1}
        %         \State {\color{blue} $\delta x \leftarrow$ Using \eqref{eq:state_error}}
        %         \State $\bar{u}_k = u_k + K_k \delta x + \alpha d_k$
        %         \State $\bar{x}_{k+1} \leftarrow f(\bar{x}_k, \bar{u}_k)$
        %     \EndFor
        %     \State $J \leftarrow$ Calculate cost using $\traj{x},\traj{u}$ 
        %     \If{$J$ {\color{blue} satisfies line search conditions}}
        %         \State $x_{0:N} \leftarrow \bar{x}_{0:N}, u_{0:N-1} \leftarrow \bar{u}_{0:N-1}$
        %     \Else
        %         \State Reduce $\alpha$ and go to line 3
        %     \EndIf\\
        %     \Return $X,U,J$
        % \EndFunction
        % \end{algorithmic}
        % \end{algorithm}
    
    \subsection{Quaternion Cost Functions} \label{sec:cost_functions}
        In addition to the straight-forward modifications to the LQR algorithm itself, we need to carefully consider the types of cost functions we minimize. We frequently minimize costs that penalize distance from a goal state, e.g. $\half (x-x_g)^T Q (x-x_g)$; however, na\"ive substraction of unit quaternions is ill-defined. We propose two different cost functions that accomplish similar behavior. 
        For sake of clarity and space, we only consider the costs on the quaternion variables: costs on the other states and the control variables remain unaffected.
        
        \subsubsection{Error Quadratic}
            Rather than simple subtraction, we can use a quadratic function on the three-parameter error state \eqref{eq:state_error}:
            \begin{equation} \label{eq:error_quadratic}
                J_\text{err} = \half \phi^T Q \phi = \half \left(\varphi^{-1}(\delta q)\right)^T Q \left(\varphi^{-1}(\delta q)\right).
            \end{equation}
            where $\delta q = L(q_g)^T q$, and $\phi = \varphi{\delta q}$. The gradient and Hessian of \eqref{eq:error_quadratic} are 
            \begin{equation}
                \nabla J_\text{err }= \phi^T Q  D(\delta q)  G(\delta q)
            \end{equation}
            \begin{equation}
                \begin{aligned}
                     \nabla^2 J_\text{err} &= 
                        G(\delta q)^T \! \left(
                        D(\delta q)^T Q D(\delta q) + \nabla D \right) G(\delta q) 
                      + I_3 (\phi^T Q  D(\delta q)) \delta q %\\
                    %  &+ G(\delta q)^T \nabla D \left(\delta q, Q \phi \right) G(\delta q) \\
                \end{aligned}
            \end{equation}
            where, for the Cayley map,
            \begin{equation}
                D(q) = \pdv{\varphi^{-1}}{q} = -\frac{1}{q_s^2}\begin{bmatrix}
                    q_v \;\; & -\frac{1}{q_s} I_3
                \end{bmatrix}
            \end{equation}
            \begin{equation}
                \nabla D = \pdv{q}(D(q)^T Q \phi) 
                = -\frac{1}{q_s^2} \begin{bmatrix} -2 \frac{q_v}{q_s}^T Q \phi \;\;  & \phi^T Q \\
                                   Q \phi \;\; & 0 \\
                \end{bmatrix}.
            \end{equation}
            
            % where $\delta q \in \R^4 = L(q_g)^T q$, $\psi \in \R^3 = \varphi(\delta q)$, and $\nabla \varphi^{-1}(q) \in \R^{3 \times 4} \equiv \pdv*{\varphi^{-1}}{q}$.
            
            % \begin{equation}
            %     \nabla_{x} = \psi^T Q \pdv{\varphi^{-1}}{q} L(\delta q) \pdv{\varphi}{\phi}
            % \end{equation}
            
            
            % \noindent We can obtain the Hessian through the chain rule:
            % \begin{equation}
            %     \begin{aligned}
            %          \nabla^2_{xx} &= \pdv{\varphi}{\phi}^T L(\delta q)^T \left(\pdv{\varphi^{-1}}{q}\right)^T Q \left(\pdv{\varphi^{-1}}{q}\right) L(\delta q) \pdv{\varphi}{\phi} \\
            %          &+ \pdv{\varphi}{\phi}^T L(\delta q)^T 
            %          \nabla^2 \varphi^{-1} \left(\delta q, Q \psi \right) L(\delta q) \pdv{\varphi}{\phi} \\
            %          &+ \nabla^2 \varphi \left(\delta q, L(\delta q)^T \pdv{\varphi^{-1}}{q} Q \psi \right)
            %     \end{aligned}
            % \end{equation}
            % Evaluating at $\phi = 0$ we get the gradient
            
            
        \subsubsection{Geodesic Distance}
            Alternatively, we can use the geodesic distance between two quaternions \cite{Kuffner2004},
            \begin{equation} \label{eq:quat_geodesic}
                J_\text{geo} = (1-\abs{q_g^T q}) ,
            \end{equation}
            whose gradient and Hessian are,
            \begin{align}
                \nabla J_\text{geo} &= \pm q_g^T G(q) \\
                \nabla^2 J_\text{geo} &= \pm I_3 q_g^T q ,
            \end{align}
            where the sign of the Hessian corresponds to the sign of $q_d^T q$.
            
            
 

\section{Experiments} \label{sec:experiments}
    Code code for all experiments is available on GitHub at \url{\texttt{https://github.com/RoboticExplorationLab/PlanningWithAttitude}}.
        
    \subsection{Trajectory Optimization}
        In this section we present several trajectory optimization problems solved using our modified version of ALTRO. 
        The two quadrotor examples use 101 knot points for 5 second trajectories, and the airplane example uses 51 knot points for a 1.25 second trajectory. All results were run on a desktop computer with an Intel i9-9900 3.10 GHz processor with 32GB of memory. Timing results for all three experiments are given in Fig. \ref{fig:timing_chart}. 
        
        In all examples, MLQR is implemented with a unit quaternion attitude state and Rodrigues parameters as the error state. The first example compares the two cost functions given in Sec. \ref{sec:cost_functions}, while the last two use the geodesic quaternion cost and compare iterative MLQR (iMLQR) from Sec. \ref{sec:MLQR} to iLQR using roll-pitch-yaw Euler angles following the convention from \cite{michael2010grasp}, and quaternions (treating them na\"ively as vectors). All examples re-normalize the quaternion in the dynamics function and use a third-order explicit Runge-Kutta integrator.
        
        \begin{figure}
            \centering
            \includegraphics[height=4cm, width=8cm]{figures/timing_chart.tikz}
            \caption{Timing results for the airplane barrell roll, quadrotor flip, and quadrotor zig-zag examples using iLQR with roll-pitch-yaw Euler angles (RPY), quaternions, and iMLQR. The timing result for the Quadrotor flip with Euler angles is omitted since it failed to converge.}
            \label{fig:timing_chart}
        \end{figure}
        
        
        \subsubsection{Quadrotor Zig-Zag}
            \begin{figure}[t]
                \centering
                \begin{subfigure}[t]{0.55\textwidth}
                    \includegraphics[height=5.2cm]{figures/zig_zag_tracking.png}
                    \caption{Zig-zag trajectory. The black quadrotors indicate the reference trajectory generated by iMLQR. The yellow quadrotors track the reference trajectory using time-varying MLQR, while the red uses the HFCA controller from \cite{watterson2020control}.}
                    \label{fig:zig-zag}
                \end{subfigure}
                ~
                \begin{subfigure}[t]{0.40\textwidth}
                    \centering
                    \includegraphics[height=5.2cm,trim={0 3cm 0 0},clip]{figures/quad_flip.png}
                    \caption{Snapshots of the quadrotor flip trajectory. The red-colored quadrotors represent the state near t=0 s and the green-colored quadrotors represent the state near t=5.0 s}
                    \label{fig:quad_flip}
                \end{subfigure}
                \caption{Examples applying MLQR to trajectory optimization on quadrotors}
            \end{figure}    
            
        % \begin{figure}[t]
        %     \begin{minipage}{0.69\linewidth}
        %         \centering
        %         \includegraphics[height=7cm]{figures/zig_zag_tracking.png}
        %         \caption{Zig-zag trajectory. The black quadrotors indicate the reference trajectory generated by iMLQR. The yellow quadrotors track the reference trajectory using time-varying MLQR, while the red uses the SE(3) controller from \cite{lee2010geometric}}
        %         \label{fig:zig-zag}
        %     \end{minipage}
        %     \begin{minipage}{0.3\linewidth}
        %         \centering
        %         \begin{tabular}{cc}
        %             \toprule
        %             \textbf{Method} & \textbf{Success} \\
        %             \midrule
        %             Quat & 62\% \\
        %             RPY  & 79\% \\
        %             HFCA & 97\% \\
        %             MLQR & 98\% \\
        %             \bottomrule
        %         \end{tabular}
        %         \captionsetup{type=table}
        %         \caption{Success rate for Monte-Carlo analysis of quadrotor stabilization}
        %         \label{tab:mlqr_success}
        %     \end{minipage}
        % \end{figure}
    
        We set up a fairly simple trajectory optimization problem to achieve a ``zig-zag'' pattern, as shown in Fig. \ref{fig:zig-zag} using cost funtions of the form 
        \begin{equation}
                  \half \sum_{k \in \mathcal{N}} \ell(x_k, x_\text{nom}, Q_\text{nom}) 
                + \half \sum_{k \in \mathcal{W}} \ell(x_k, \bar{x}_k, Q_w) 
                + \half \sum_{k=0} u_k^T R u_k
        \end{equation}
        with $\mathcal{W} = \{33,66,101\}$, $\mathcal{N} = \{1:101\} \setminus \mathcal{W}$, and the waypoint positions were $(10,0,1)$,$(-10,0,1)$ and $(0,10,0)$. We compared the two cost functions from Sec. \ref{sec:cost_functions}, using a standard quadratic penalty on the non-quaternion states. 
        \begin{align}
            \ell_\text{err}(x, \bar{x}, Q) &= \delta x^T Q \delta x \\ 
            \ell_\text{geo}(x, \bar{x}, Q) &= (x-\bar{x})^T \bar{Q} (x-\bar{x}) + w (1 \pm \bar{q}^T q)
        \end{align}
        where $\bar{Q} = \text{diag}(Q_r, \vec{0}_4, Q_v, Q_\omega)$, where $Q_r,Q_v,Q_\omega$ are the weights of $Q$ for position, and linear and angular velocity.
        We used the following weighting matrices: 
        $Q_\text{nom} = \text{diag}(10^{-5} I_6,10^{-3} I_6)$, 
        $Q_w = \text{diag}(10^3 I_3,I_9)$, 
        $Q_N = \text{diag}(10 I_3, 100 I_3, 10 I_6)$.
        For the geodesic weights $w$, we used 0, 1, and 10 for the nominal, waypoint, and terminal cost functions, respectively. 
        
        
        The geodesic cost function performed significantly better than the error quadratic, converging in 10 ms and 13 iterations, compared to 53 ms in 29 iterations. 
        In addition to better convergence behavior, the geodesic cost is about half as expensive to compute, which is unsurprising when comparing the gradients and Hessians in Sec. \ref{sec:cost_functions}. 
        
        \subsubsection{Quadrotor Flip}
	    
	    Similar to the previous example, we use a set of waypoints to encourage the quadrotor to do a flip. The cost weights for this example were 
	    \begin{align*}
	        Q_\text{nom} &= \text{diag}(10^{-2},10^{-2},5 \times 10^{-2}, 10^{-3} I_3, 10^{-3} I_3, 10^{-2} I_3) \\
	        Q_w &= \text{diag}(10^3, 10, 10^3, 5000 I_3, I_3, 10 I_3) \\
	        Q_N &= \text{diag}(10 I_3, 100 I_3, 10 I_6)  
	    \end{align*}
	    Four intermediary knotpoints were used to encourage the quadrotor to be at angles of \ang{90},  \ang{180}, \ang{270}, and \ang{360}. The quadrotor was constrained to stay above the floor and move to a goal state 2 meters away in the $+y$ direction. The solver is initialized with a dynamically infeasible trajectory that linearly interpolates between the initial and final states, rotating the quad around the x-axis a full \ang{360}.
	    
	    Figure \ref{fig:quad_flip} shows snapshots of the trajectory as generated using iMLQR within the ALTRO solver to handle constraints. The trajectory generated by iLQR with quaternions and quadratic costs was successful but had a slightly different trajectory. iLQR with Euler angles failed to solve the problem. 
        % \begin{figure}[t]
        %     \centering
        %     \includegraphics[height=6cm]{figures/quad_flip.png}
        %     \caption{Snapshots of the quadrotor flip trajectory. The red-colored quadrotors represent the state near t=0 s and the green-colored quadrotors represent the state near t=5.0 s}
        %     \label{fig:quad_flip}
        % \end{figure}
        
        \subsection{Airplane Barrel Roll}
        An airplane model with aerodynamic coefficients fit from real wind-tunnel data is tasked to do a barrel roll by setting a high terminal cost for being upside-down, see Fig. \ref{fig:barrellroll}.
        The solver is initialized with level flight trim conditions. 
        For both the quadrotor flip and the airplane barrel roll, iMLQR converged faster than the pure quaternion version. Despite the extra matrix multiplications and extra Hessian term, it also was faster per iteration than its iLQR counterpart. For these highly aerobatic maneuvers, we achieve, as expected, better performance by correctly leveraging the structure of the rotation group during the optimization routine.
        
        \begin{figure}[h]
            \centering
            \includegraphics[height=3.5cm]{figures/barrellroll.png}
            \caption{Barrel roll trajectory computed by iterative MLQR using a terminal cost to encourage an upside-down attitude.}
            \label{fig:barrellroll}
        \end{figure}
    
	    \begin{figure}[h]
	        \centering
	        \includegraphics[width=\columnwidth,height=4.5cm]{figures/tracking_err.tikz}
	        \caption{Tracking error over time for the zig-zag trajectory using MLQR and the HFCA geometric controller. Band-limited white noise wrenches of variance $w$ are added to the continuous dynamics. }
	        \label{fig:tracking_err}
	    \end{figure}
	    \vspace{-20pt}
	    
	\subsection{Tracking Control}
	   % \begin{wrapfigure}{r}{0.5\textwidth}
	   %     \centering
	   %     \includegraphics{figures/mlqr_basin.tikz}
	   %     \caption{Basin of attraction}
	   %     \label{fig:mlqr_basin}
	   % \end{wrapfigure}
	   
	    This section provides examples using MLQR for tracking and stabilizing control for a quadrotor. We compare our MLQR controller to HFCA, a state-of-the-art geometric tracking controller \cite{watterson2020control} based on the Hopf Fibration. 
	    
	    \subsubsection{MLQR Stabilization}
	    To test robustness and the domain of attraction of the MLQR controller, a quadrotor is linearized about hover at the origin and initialized from states uniformly sampled in $[-1,1]$ for position, $[-5,5]$ for linear and angular velocities, and uniformly over the entire space of rotations. The success rates for 2000 trials are given in Table \ref{tab:mlqr_success}, where success is defined as the terminal error (calculated using \eqref{eq:state_error}) being within a unit ball of radius 0.1 after 10.0 seconds.
	    To further analyze the basins of attraction, we uniformly sampled over only roll (which goes singular at \ang{90} for our Euler angle representation), and yaw. The results are shown in Fig. \ref{fig:mlqr_basin}, where the plotted contours are the convex hull of the successfully stabilized initial conditions.
	    
	    MLQR slightly exceeds the robustness of the HFCA geometric controller, while also being more generally applicable, easier to tune, and easier to implement. It is also noteworthy that na\"ively using LQR with quaternions (incorrectly treating them as vectors) results in poorer performance than Euler angles, clearly demonstrating the value of the methodology presented in the current paper.
	    
	    \subsubsection{MLQR Tracking}
	    Time-varying MLQR is used to track the zig-zag trajectory generated in the previous section. %The controller calculated the gains at $0.01 s$ intervals, and used zero-order-hold between intervals. 
	    To test tracking performance, zero-mean Gaussian noise was added as force and moments applied to the quadrotor.
	    
	    The trajectories and tracking error for MLQR and HFCA are shown in Figs. \ref{fig:zig-zag}, and \ref{fig:tracking_err}. While the MLQR controller dramatically out-performs HFCA, we found no significant difference in performance between MLQR and LQR using either roll-pitch-yaw Euler angles or a quaternion. Since the tracking controller only deals with relatively small state and attitude errors, this is unsurprising. Additionally, we found the MLQR controller ran about 20x faster than the HFCA controller.
	    
	    
	    \begin{figure}[h]
	        \begin{minipage}{0.60\linewidth}
    	        \centering
    	        \includegraphics[height=6.6cm,width=\textwidth]{figures/mlqr_basin.tikz}
    	        \caption{Basins of attraction of 4 stabilizing controllers for yaw and roll, calculated from 2000 sample points (shown in black). All points within each contour were successfully stabilized by the controller.}
    	        \label{fig:mlqr_basin}
	        \end{minipage}
	        \hspace{0.05\linewidth}
            \begin{minipage}{0.34\linewidth}
                \centering
                \begin{tabular}{cc}
                    \toprule
                    \textbf{Method} & \textbf{Success} \\
                    \midrule
                    Quat & 61\% \\
                    RPY  & 80\% \\
                    HFCA & 97\% \\
                    MLQR & 99\% \\
                    \bottomrule
                \end{tabular}
                \captionsetup{type=table}
                \caption{Success rate for Monte-Carlo analysis of quadrotor stabilization for 2000 initial conditions uniformly over position, orientation, and linear and angular velocities.}
                \label{tab:mlqr_success}
            \end{minipage}
	    \end{figure}
        
        
\section{Conclusions} \label{sec:conclusion}
    We have presented a general, unified method for planning and control on rigid-body systems with arbitrary attitude using standard linear algebra and vector calculus. By applying these methods to LQR to correctly account for the group structure of rotations, we have matched or exceeded the performance of a state-of-the-art geometric controller designed specifically for quadrotors, while being more general, requiring less system-dependent tuning, having less computational overhead, and being easier to implement. 
    
    We have also demonstrated a straight-forward way to adapt nonlinear trajectory optimization techniques to work with quaternion-valued states.
    For these problems, we found the geodesic distance between quaternions \eqref{eq:quat_geodesic} to be computationally efficient and provide excellent convergence in practice. We recommend the use of unit quaternions within planning and control algorithms for their simplicity, computational efficiency, and lack of singularities. We further recommend the use of Rodrigues parameters, or the Cayley map, as the quaternion error state. 
    
    Future areas of research include the application of these methodologies to more complex multi-body floating-base robots, such as humanoids and quadrupeds, as well as more in-depth analysis of the convergence behavior of the algorithms proposed in the current work.
    
\paragraph{Acknowledgements}
This material is based upon work
supported by the National Science Foundation Graduate Research Fellowship Program under Grant No. DGE-1656518.
Any opinions, findings, and conclusions or recommendations
expressed in this material are those of the author(s) and
do not necessarily reflect the views of the National Science
Foundation


\printbibliography
\end{document}
