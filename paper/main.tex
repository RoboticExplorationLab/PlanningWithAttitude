
\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out if you need a4paper
\IEEEoverridecommandlockouts                              % This command is only needed if 
                                                          % you want to use the \thanks command
\overrideIEEEmargins                                      % Needed to meet printer requirements.
\usepackage[top=60pt, left=48pt, right=48pt, bottom=43pt]{geometry}


% Bibliography
\usepackage{biblatex}
\addbibresource{references.bib}

% Math
\usepackage{physics}
\usepackage{siunitx}
\sisetup{output-exponent-marker=\ensuremath{\mathrm{e}}}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{tensor}

% Optimization and Algorithms
\usepackage{optidef}
\usepackage{algorithmicx}
\usepackage{algorithm,algpseudocode}

% Formatting
\usepackage{xcolor}
\usepackage{bm}  % for bold symbols 
\usepackage{booktabs}  % better tables
\usepackage{pifont}  % for x mark
\usepackage{graphicx}
\usepackage{hyperref}

% Plotting
\usepackage{pgfplots}
\pgfplotsset{compat=1.15,
	legend style={font=\footnotesize},
}
\usepackage{tikzscale}
% \pgfplotsset{every axis plot post/.style={
%     very thick,
% }
% }

% Custom commands
\newcommand{\half}{\frac{1}{2}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{S}^3}
\newcommand{\skewmat}[1]{[#1]^\times}

\newcommand{\rmap}{\varphi}
\newcommand{\invrmap}{\varphi^{-1}}

\DeclareMathOperator{\sign}{sign}

\newcommand{\dR}{\delta \mathcal{R}}
\newcommand{\rot}{ \mathcal{R} }
\newcommand{\dq}{\delta q}
\newcommand{\q}{\textbf{q}}
\newcommand{\eq}{_\text{eq}}
\newcommand{\traj}[2][N]{#2_{0:{#1}}}
\newcommand{\pass}{{\color{green} \checkmark}}
\newcommand{\fail}{{\color{red} \ding{55}}}
\newcommand{\inframe}[2]{{}^{#1}\!#2}
\newcommand{\toframe}[3]{\inframe{#1}{#3}^{#2}}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}


\title{\LARGE \bf
Planning with Attitude
}

\author{Brian E. Jackson$^1$, Kevin Tracy$^1$, and Zachary Manchester$^1$%
    \thanks{
        $^1$Robotics Institute, 
        Carnegie Mellon University, 
        5000 Forbes Ave, Pittsburgh, PA, USA
    }
}

\begin{document}
\maketitle

\begin{abstract}
Planning trajectories for floating-base robotic systems that experience
large attitude changes is challenging due to the nontrivial group structure of 3D
rotations. This paper introduces a powerful and accessible approach for 
optimization-based planning on the space of rotations using only standard linear algebra and vector calculus. We demonstrate the effectiveness of the approach by adapting Newton's
method to solve the canonical Wahba's problem, and modify the trajectory optimization solver ALTRO to plan directly on the space of unit 
quaternions, achieving superior convergence on problems involving significant changes 
in attitude.
%\keywords{trajectory optimization, motion planning, control, quaternions}

\end{abstract}

\section{INTRODUCTION}

    Many robotic systems---including quadrotors, airplanes, satellites, autonomous
    underwater vehicles, and quadrupeds---can perform arbitrarily large three-dimensional
    translations and rotations as part of their normal operation. While representing
    translations is straightforward and intuitive, effectively representing the
    nontrivial group structure of 3D rotations has been a topic of study for many
    decades. Although we can intuitively deduce that rotations are three-dimensional, a
    globally non-singular three-parameter representation of the space of rotations does
    not exist \cite{stuelpnagel1964parametrization}. As a result, when parameterizing
    rotations, we must either a) choose a three-parameter representation and deal with
    singularities and discontinuities, or b) choose a higher-dimensional representation and deal with
    constraints between the parameters. While simply representing attitude is nontrivial,
    generating and tracking motion plans for floating-base systems is an even more
    challenging problem.

    Early work on control problems involving the rotation group dates back to the 1970s,
    with extensions of linear control theory to spheres \cite{Brockett1973} and $SO(3)$
    \cite{Baillieul1978}. Effective attitude tracking controllers have been developed for
    satellites \cite{wie1985quaternion}, quadrotors
    \cite{Fresk2013,Liu2015,lee2010geometric,
    Johnson2005,watterson2020control,mellinger2011minimum}, and a 3D inverted pendulum
    \cite{Chaturvedi2009} using various methods for calculating three-parameter attitude
    errors.

    More recently, these ideas have been extended to trajectory generation
    \cite{Zefran1998}, sample-based motion planning \cite{Zefran1999,Kuffner2004}, and
    optimal control. Approaches to optimal control with attitude states include
    analytical methods applied to satellites \cite{Spindler1998}, discrete mechanics
    \cite{Kobilarov2011,Kobilarov2014, Lee2008}, a combination of sampling-based planning
    and constrained trajectory optimization for satellite formations \cite{Garcia2005,
    Aoude2008}, projection operators \cite{Saccon2013}, or more general theory for
    optimization on manifolds \cites{watterson2018trajectory}. Nearly all of these
    methods rely heavily on principles from differential geometry and Lie group theory;
    however, despite these works, many recent papers in the robotics community continue
    to naively apply standard methods for motion planning and control with no regard for the
    group structure of rigid body motion.
    %\cite{Alothman2016,deCrousaz2015, Williams2017,Geisert2016}
    
    In this paper, we make a departure from previous approaches to geometric planning and
    control that rely heavily on ideas and notation from differential geometry, and
    instead use only basic mathematical tools from linear algebra and vector calculus
    that should be familiar to most roboticists. In Sec. \ref{sec:Quaternion_Calculus} we
    introduce an approach to quaternion differential calculus similar to
    \cite{Mandic2011,Xu2016}, but significantly simpler and more general, enabling
    straight-forward adaptation of existing algorithms to systems with quaternion states.
    For concreteness, we then apply our method to the canonical Wahba's
    problem~\cite{Wahba1965} in Sec. \ref{sec:Wahbas}, and demonstrate superior
    convergence to approaches that fail to properly account for the group structure. In
    Sec. \ref{sec:trajopt} we extend these ideas to the problem of trajectory
    optimization, and detail modifications to ALTRO, a state-of-the-art constrained
    trajectory optimization solver, and demonstrate performance gains on several
    benchmark problems. With the modifications presented in this paper, ALTRO explicitly 
    leverages both the structure of the trajectory optimization problem as well as the 
    group structure of 3D rotations, making it uniquely well-suited to solving challenging
    problems with near real-time performance.

    %To our knowledge, there does not currently exist a solver that is capable of leveraging the unique Markovian structure of the fixed-horizon trajectory optimization problem while correctly accounting for the group structure of 3D rotations. 
    In summary, our contributions include:

    \begin{itemize}
        \item A unified approach to quaternion differential calculus entirely based on
        standard linear algebra and vector calculus.
        \item Derivation of a Newton-based algorithm for nonlinear optimization directly
        on the space of unit quaternions.
        \item Implementation of a fast and efficient solver for trajectory optimization
        problems with attitude dynamics and nonlinear constraints that correctly accounts
        for the group structure of 3D rotations.
    \end{itemize}


\section{Background}

    We begin by defining some useful conventions and notation. 
    Attitude is defined as the rotation from the robot's body frame to the world frame.
    We also define gradients to be row vectors, that is, for 
        $f(x) : \R^n \to \R$, $\pdv{f}{x} \in \R^{1\times n}$.

    \subsection{Unit Quaternions} \label{sec:quaternions}
        We leverage the fact that quaternions are linear operators and that the space of
        quaternions $\mathbb{H}$ is isomorphic to $\R^4$ to explicitly
        represent---following the Hamilton convention---a quaternion $\q \in \mathbb{H}$
        as a standard vector $q \in \R^4 := [q_s \;\; q_v^T]^T$ where $q_s \in \R$ and
        $q_v \in \R^3$ are referred to as the scalar and vector parts of the quaternion,
        respectively. The space of unit quaternions, $\Q = \{q : \norm{q}_2 = 1\}$, is a 
        a double-cover of the rotation group $SO(3)$, since $q$ and $-q$ represent the same 
        rotation \cite{markley2014fundamentals}.
        
        Quaternion multiplication is defined as
        \begin{equation} \label{eq:quat_mult}
            \q_2 \otimes \q_1 = L(q_2) q_1 = R(q_1) q_2
        \end{equation}
        where $L(q)$ and $R(q)$ are orthonormal matrices defined as
        \begin{align}
            L(q) &:= \begin{bmatrix} 
                q_s \;\; & -q_v^T \\ 
                q_v \;\; & q_s I + \skewmat{q_v} 
            \end{bmatrix} 
            \label{eq:Lmult} \\
            %= \begin{bmatrix} q & G(q) \end{bmatrix} \label{eq:Lmult} \\
            R(q) &:=\begin{bmatrix} 
                q_s \;\; & -q_v^T \\ 
                q_v \;\; & q_s I - \skewmat{q_v} 
            \end{bmatrix} \label{eq:Rmult},
        \end{align}
        and $\skewmat{x}$ is the skew-symmetric matrix operator
        \begin{equation}
            \skewmat{x} := \begin{bmatrix} 
                0 & -x_3 & x_2 \\ 
                x_3 & 0 & -x_1\\ 
                -x_2 & x_1 & 0 
            \end{bmatrix}.
        \end{equation}
        
        The inverse of a unit quaternion $\q^{-1}$, giving the opposite rotation, is equal 
        to its conjugate $\q^*$, which is simply the same quaternion with a negated vector 
        part:
        \begin{equation} \label{eq:T}
            \q^* = T q := \begin{bmatrix} 
                1 & \\ 
                & -I_3 
            \end{bmatrix} q
        \end{equation}
        The following identities, which are easily derived from
        \eqref{eq:Lmult}--\eqref{eq:T}, are extremely useful:
        \begin{align}
            &L(Tq) = L(q)^T = L(q)^{-1} \\
            &R(Tq) = R(q)^T = R(q)^{-1} .
        \end{align}
        
        We will sometimes find it helpful to create a quaternion with zero scalar part from 
        a vector $r \in \R^3$. We denote this operation as,
        \begin{equation}
            \hat{r} = H r \equiv \begin{bmatrix} 0 \\ I_3 \end{bmatrix} r.
        \end{equation}
        Unit quaternions rotate a vector through the operation 
        $\hat{r}' = \q \otimes \hat{r} \otimes \q^*$. 
        This can be equivalently expressed using matrix multiplication as
        \begin{align} 
            r' &= H^T L(q) R(q)^T H r = A(q)r , \label{eq:quaternion_rotation}
        \end{align}
        where $A(q)$ is the rotation matrix in terms of the elements of the quaternion 
        \cite{kane1983spacecraftdynamics}.

    \subsection{Rigid Body Dynamics} \label{sec:rigidbody_dynamics}
        For clarity, we will restrict our attention to rigid bodies moving freely in 3D 
        space. That is, we consider systems with dynamics of the following form:
        \begin{equation} \label{eq:rigid_body_dynamics}
            x = \begin{bmatrix} r \\ R \\ v \\ \omega \end{bmatrix}, \quad 
            \dot{x} = \begin{bmatrix} 
                v \\ 
                \half \q \otimes \hat{\omega} = \half L(q) H \omega \\ 
                \frac{1}{m} \inframe{W}{F(x,u)} \\ 
                J^{-1}(\inframe{B}{\tau(x,u)} - \omega \times J \omega) 
            \end{bmatrix}
        \end{equation}
        where $x$ and $u$ are the state and control vectors, $r \in \R^3$ is the
        position, $\q \in \Q$ is the attitude, $v \in \R^3$ is the linear velocity, and
        $\omega \in \R^3$ is the angular velocity. $m \in \R$ is the mass, $J \in
        \R^{3\times3}$ is the inertia matrix, $\inframe{W}{F(x,u)} \in \R^3$ are the
        forces in the world frame, and $\inframe{B}{\tau(x,u)}$ are the moments in the
        body frame.

\section{Quaternion Differential Calculus} \label{sec:Quaternion_Calculus}
    We now present a simple but powerful method for taking derivatives of functions 
    involving quaternions based on the notation and linear algebraic operations outlined 
    in Sec. \ref{sec:quaternions}.
    
    \begin{figure}
        \centering
        \includegraphics[height=5cm]{figures/tangent_plane.tikz}
        \caption{
            When linearizing about a point $q$ on an sphere $\mathbb{S}^{n-1}$ in 
            n-dimensional space, the tangent space $T$ is a plane living in $\R^{n-1}$, 
            illustrated here with $n=3$. Therefore, when linearizing about a unit 
            quaternion $q \in \Q$, the space of differential rotations lives in $\R^3$.
        }
        \label{fig:tangent_plane}
    \end{figure}
        
        Derivatives consider the effect an infinitesimal perturbation to the input has on
        an infinitesimal perturbation to the output. For vector spaces, the composition
        of the perturbation with the nominal value is simple addition and the
        infinitesimal perturbation lives in the same space as the original vector. For
        unit quaternions, however, neither of these are true; instead, they compose
        according to \eqref{eq:quat_mult}, and infinitesimal unit quaternions are (to
        first order) confined to a 3-dimensional plane tangent to $\Q$ (see Fig.
        \ref{fig:tangent_plane}).

        The fact that differential unit quaternions are three-dimensional should make
        intuitive sense: Rotations are inherently three-dimensional and differential
        rotations should live in the same space as angular velocities, i.e. $\R^3$.
        
        There are many possible three-parameter representations for small rotations in
        the literature. Many authors use the exponential map \cite{Baillieul1978,
        Zefran1998, Lee2008, Saccon2013, Sola2017, Fan2016, watterson2018trajectory},
        while others have used the Cayley map (also known as Rodrigues parameters)
        \cite{Kobilarov2011, Kobilarov2014}, Modified Rodrigues Parameters (MRPs)
        \cite{Terzakis2018}, or the vector part of the quaternion \cite{Fresk2013}.
        We choose Rodrigues parameters \cite{markley2014fundamentals} because they are
        computationally efficient and do not inherit the sign ambiguity associated with
        unit quaternions. The mapping between a vector of Rodrigues parameters $\phi \in
        \R^3$ and a unit quaternion $q$ is known as the Cayley map: \begin{equation}
        \label{eq:cayley}
            q = \varphi(\phi) = \frac{1}{\sqrt{1 + \norm{\phi}^2}} \begin{bmatrix} 1 \\ \phi \end{bmatrix}.
        \end{equation}
        We will also make use of the inverse Cayley map:
        \begin{equation}
            \phi = \varphi^{-1}(q) = \frac{q_v}{q_s}.
        \end{equation}

    \subsection{Jacobian of Vector-Valued Functions}
        When taking derivatives with respect to quaternions, we must take into account
        both the composition rule and the nonlinear mapping between the space of unit
        quaternions and our chosen three-parameter error representation.

        Let $\phi \in \R^3$ be a differential rotation applied to a function with
        quaternion inputs $y = h(q): \Q \to \R^p$, such that
        \begin{equation} \label{eq:vector_function}
            y + \delta y = h(L(q) \varphi(\phi)) \approx h(q) +  \nabla h(q) \phi.
        \end{equation}
        We can calculate the Jacobian $\nabla h(q) \in \R^{p \times 3}$ by
        differentiating \eqref{eq:vector_function} with respect to $\phi$, evaluated at
        $\phi = 0$:
        \begin{equation} \label{eq:quat_gradient}
            \nabla h(q) = \pdv{h}{q} L(q) H := \pdv{h}{q} G(q) 
                        = \pdv{h}{q} \begin{bmatrix} 
                            -q_v^T \\ 
                            q_s I_3 + \skewmat{q_v}
                        \end{bmatrix}
        \end{equation}
        where $G(q) \in \R^{4 \times 3}$ is the \textit{attitude Jacobian}, which
        essentially becomes a ``conversion factor'' allowing us to apply results from
        standard vector calculus to the space of unit quaternions. This form is
        particularly useful in practice since $\pdv*{h}{q} \in \R^{p \times 4}$ can be
        obtained using finite differences or automatic differentiation.
        As an aside, although we have used Rodrigues parameters, $G(q)$ is actually the
        same (up to a constant scalar factor) for any choice of three-parameter attitude
        representation.

    \subsection{Hessian of Scalar-Valued Functions}
	    If the output of $h$ is a scalar ($p = 1$), then we can find its Hessian by
	    taking the Jacobian of \eqref{eq:quat_gradient} with respect to $\phi$ using the
        product rule, again evaluated at $\phi = 0$:

	    \begin{equation} \label{eq:quat_hessian}
            \nabla^2 h(q) = G(q)^T \pdv[2]{h}{q} G(q) + I_3 \pdv{h}{q}q,
	    \end{equation}
	    where the second term comes from the second derivative of $\varphi(\phi)$.
	    Similar to $G(q)$, this expression is the same (up to a constant scalar factor) for any
        choice of three-parameter attitude representation.
        
    \subsection{Jacobian of Quaternion-Valued Functions}
        We now consider the case of a function that maps unit quaternions to unit
        quaternions, $q' = f(q) : \Q \to \Q$. 
        % \todo{Let's make sure we're bing consistent with our usage of $\Q$ vs. $\mathbb{H}$.} 
        Here we must also consider the non-trivial
        effect of a differential rotation applied to the output, i.e.:
        \begin{equation} \label{eq:dqoutput}
            L(q') \varphi(\phi') = f(L(q)\varphi(\phi)) .
        \end{equation}
        Solving \eqref{eq:dqoutput} for $\phi'$ we find,
        \begin{equation} \label{eq:phiprime}
            \phi' = \varphi^{-1} \left( L(q')^T f(L(q)\varphi(\phi)) \right) \approx \nabla f(q) \, \phi.
        \end{equation}
        Finally, the desired Jacobian is obtained by taking the derivative of
        \eqref{eq:phiprime} with respect to $\phi$:
        \begin{equation} \label{eq:quat_jacobian}
            \nabla f(q) = H^T L(q')^T \pdv{f}{q} L(q) H = G(q')^T \pdv{f}{q} G(q).
        \end{equation}
        %The leading $G(q')^T$ comes from the fact that as $\phi' \to 0$, $L(q') f(q) \to
        %I_q$, where $I_q$ is the quaternion identity.
        Once again, \eqref{eq:quat_jacobian} holds (up to a constant) for any
        three-parameter attitude representation.
        
        %Differentiating through the inverse map, evaluated at the quaternion identity, we find that $\pdv*{\varphi^{-1}}{q}\to H^T$ for any three-parameter attitude representation.


\section{Modifying Newton's Method} \label{sec:Wahbas}

% \todo{I would re-work this section to only talk about the details of doing it the ``correct'' way (i.e. consistent with the previous section). Then just call the standard version a ``naive Newton method in which the quaternion is re-normalized at each step'' and don't bother writing any of the mathematical details for that version. I think it will get confusing if you mix derivative types/notation.}

    Newton's method uses derivative information about a function to iteratively
    approximate its roots. For unconstrained systems, this method is highly effective,
    and can exhibit quadratic convergence rates. For constrained systems, the updates 
    can be projected back onto the feasible set at each iteration, but without the same
    convergence guarantees.
    %For the constraints on $SO(3)$, Newton's method struggles to
    %converge past a certain threshold due to this projection.
    
    In this section, we will leverage the quaternion calculus results introduced in the previous section to modify Newton's method so that it implicitly accounts for the quaternion unit-norm constraint. Unlike the projection approach, this modified form of Newton's method retains the fast convergence rates associated with the unconstrained method. We will demonstrate this behavior on Wahba's Problem, a least-squares attitude estimation problem~\cite{Wahba1965, markley2014fundamentals}.
    

    \subsection{Methodology}
% \todo{Let's keep our notation and language consistent for body vs. inertial frames. I propose ``body'' (B) and ``inertial'' or ``world'' (W), which is the standard in robotics.}
    Given a set of known vectors in the world frame, $\inframe{W}{w_i}$, and measurements of these vectors in the body frame, $\inframe{B}{v_i}$, we seek the
    rotation from the body to the world frame $\toframe{W}{B}{A(q)}$ that solves the following optimization problem, \todo{Kevin: Don't use $L$ here because it conflicts with \eqref{eq:Lmult}:}
    \begin{mini*}
        {q}{ L(q) }{}{}
        \addConstraint { q\in \Q,}
    \end{mini*}
    where Wahba's loss function $L(q)$ is,
    \begin{equation} \label{eq:wahba_loss}
        L(q) = \sum_i \norm{\inframe{W}{w_i} - A(q) \,\, \inframe{B}{v_i} }_2^2 
           = \norm{r(q)}_2^2 ,
    \end{equation} 
    and $r(q)$ is the residual vector.


    The Jacobian of $r(q)$ can be found using \eqref{eq:quat_jacobian} and \eqref{eq:quaternion_rotation}: \todo{Kevin: fix the second line of this equation:}
    \begin{equation} \label{eq:newton_foc}
        \begin{aligned}
            \nabla r(q) &= \pdv{r}{q} G(q) \\
              &= \left( \sum_i -2 H^T R(q)^T R({}^B \hat{v}_i) \right).
        \end{aligned}
    \end{equation}
    Given a guess solution, $q_k$, The standard Gauss-Newton method can then be used to compute a three-parameter update, $\phi_k$ via the Moore-Penrose psuedoinverse:
    \begin{equation}
    	\phi_k = ({\nabla r}^T {\nabla r})^{-1} {\nabla r}^T r(q_k).
    \end{equation}
	The update is then applied using the composition for the group:
	\begin{equation}
		\q_{k+1} = \q_k \otimes \varphi(\phi_k)
	\end{equation}.
	This ``multiplicative'' Gauss-Newton method is summarized in Algorithm \ref{alg:mgn}.

    \begin{algorithm} 
    	\begin{algorithmic}[1]
    		\caption{Multiplicative Gauss-Newton Method}\label{alg:mgn}
    		\State $k = 0$
    		\While{$\norm{\phi} > $ tolerance}
    		    \State ${\nabla r} = \pdv{r(q_k)}{q} G(q_k)$ 
    		    	\Comment{Compute Jacobian}
    		    \State $ \phi = -({\nabla r}^T {\nabla r})^{-1} {\nabla r}^T r(q_k)$ \Comment{Compute update step}
    		    \State $q_{k+1} = L(q_k) \varphi(\phi)$ \Comment{Apply update step}
    		    \State $k = k + 1$
    		\EndWhile
    	\end{algorithmic}
    \end{algorithm}



    \subsection{Results}
    Figure \ref{fig:wahba_convergence} compares the multiplicative Gauss-Newton method with a na\"ive Newton's method in which the quaternion is simply projected back onto the unit sphere at every iteration. That the na\"ive method makes progress
    initially, but quickly stalls.
    By correctly handling the group structure of unit quaternions, the multiplicative method is able
    to maintain the fast convergence rates typical of Newton's method.
    \begin{figure}

        \centering
        \includegraphics[width=\columnwidth, height=5cm]{figures/wahba_convergence.tikz}
        \caption{Convergence comparison for Wahba's problem. By modfying Newton's method
        with the methods of section \ref{sec:Quaternion_Calculus}, quadratic convergence
        rates are achieved, while a na\"ive approach stalls after only a few
        iterations.}
        \label{fig:wahba_convergence}
    \end{figure}

\section{Trajectory Optimization on $\R^n \times SO(3)$} \label{sec:trajopt}
    Here we outline the modifications to the ALTRO solver \cite{howell2019altro} to
    solve trajectory optimization problems for rigid bodies, which extends easily to
    arbitrary systems whose state is in $\R^n \times SO(3)$. %ALTRO is an efficient solver for constrained nonlinear optimization problems that uses iterative LQR (iLQR) with an augmented Lagrangian framework.

    We consider trajectory optimization problems of the form,
    \begin{mini}[2]
        {x_{0:N},u_{0:N-1}}{\ell_f(x_N) + \sum_{k=0}^{N-1} \ell_k(x_k,u_k) }{}{}
        \addConstraint{x_{k+1} = f(x_k,u_k)}
        \addConstraint{g_k(x_k,u_k)}{\leq 0}
        \addConstraint{h_k(x_k,u_k)}{=0}
        \label{discrete_trajopt},
    \end{mini}
    where $x$ and $u$ are the state and control vectors as described in Sec. \ref{sec:rigidbody_dynamics},
    $f$ are the dynamics as defined in \eqref{eq:rigid_body_dynamics}, $\ell_k$ is a general
    nonlinear cost function at a single time step,
    $N$ is the number of time steps, and $g_k$, $h_k$ are general nonlinear inequality and 
    equality constraints.

    Like most gradient or Newton-based methods for optimization, ALTRO approximates the
    nonlinear functions $f, \ell, g,$ and $h$ with their first or second-order Taylor
    series expansions. Leveraging the methods from Sec: \ref{sec:Quaternion_Calculus}, we
    adapt the algorithm to optimize directly on the error state $\delta x \in \R^{12}$:
    \begin{equation} \label{eq:state_error}
    	\delta x_k = \begin{bmatrix} 
            r_k - \bar{r}_k \\ \varphi^{-1}(\bar{\q}_k^{-1} \otimes \q_k) \\ v_k - \bar{v}_k \\ \omega_k - \bar{\omega}_k 
        \end{bmatrix} .
    \end{equation}

    We begin by linearizing the dynamics about the reference state and input trajectories, $\bar{x}$ and $\bar{u}$, using
    \eqref{eq:quat_jacobian}. The linearized error dynamics become,
    \begin{equation} \label{eq:linearized_dynamics}
        \delta x_{k+1} = A_k \delta x_k + B_k \delta u_k ,
    \end{equation}
    where \begin{equation}
        \begin{aligned}
            A_k = E(\bar{x}_{k+1})^T \pdv{f}{x}|_{\bar{x}_k,\bar{u}_k} E(\bar{x}_k), \\
            B_k = E(\bar{x}_{k+1})^T \pdv{f}{u}|_{\bar{x}_k,\bar{u}_k},
        \end{aligned}
    \end{equation}
    and $E(x_k) \in \R^{12 \times 13}$ is the error-state Jacobian:
    \begin{equation} \label{eq:state_error_jacobian}
        E(x) = \begin{bmatrix}
            I_3 & & & \\
            & G(q) & & \\
            & & I_3 & \\
            & & & I_3 \\
        \end{bmatrix}\!.
    \end{equation}
    By applying \eqref{eq:quat_gradient} and \eqref{eq:quat_hessian} to the nonlinear
    cost functions $\ell$ and \eqref{eq:quat_jacobian} to the nonlinear constraint
    functions $g_k$ and $h_k$, we can calculate the second-order expansion of the cost 
    function:
    \begin{multline}
        \delta \ell(x,u) \approx  \half \delta x^T \ell_{xx} \delta x
            + \half \delta u^T \ell_{uu} \delta u + \delta_u^T \ell_{ux} \delta u \\
            + \ell_x^T \delta x^T + \ell_u^T \delta u.
    \end{multline}
    % \todo{I think you can safely leave out any references to the augmented Lagrangian,
    % etc. and just talk about the cost function.}
    % \begin{equation}
    %     \mathcal{L}_A = \mathcal{L}_N(x_N,\lambda_N,\mu_N) + 
    %         \sum_{k=0}^{N-1} \mathcal{L}_k(x_k,u_k,\lambda_k,\mu_k)
    % \end{equation}
    % where
    % \begin{equation}
    %     \mathcal{L}_k(x,u,\lambda,\mu) = \ell(x,u) + 
    %         (\lambda + \half I_\mu c(x,u))^T c(x,u),
    % \end{equation}
    % with $c(x,u)$ being the concatenation of the constraints $f,g$, and $h$ at a given time step,
    % and $I_\mu$ the penalty matrix.
	
	With these results, we can apply standard Newton and quasi-Newton techniques along the lines of Section \ref{sec:Wahbas}. We can also calculate a second-order expansion of the ``action-value function'' $Q(x,u)$ needed in differential dynamic programming (DDP) and LQR-based methods,
    \begin{align}
        Q_{xx} &= \ell_{xx} + A_{k}^T P_{k+1} A_{k} \label{Qxx_exp}\\
        Q_{uu} &= \ell_{uu} + B_{k}^T P_{k+1} B_{k} \label{Quu_exp}\\
        Q_{ux} &= \ell_{ux} + B_{k}^T P_{k+1} A_{k} \label{Qux_exp}\\
        Q_x &= \ell_x  + A_{k}^T p_{k+1} \label{Qx_exp}\\
        Q_u &= \ell_u + B_{k}^T p_{k+1} \label{Qu_exp},
    \end{align}
    from which we can calculate the quadratic expansion of the cost-to-go 
    $P_k \in \R^{12 \times 12}$, $p_k \in \R^{12}$, and optimal linear feedback gains 
    $K_k \in \R^{m \times 12}$ and feed-forward corrections $d_k \in \R^m$ by starting at the terminal state and
    performing a backward Riccati recursion as usual~\cite{li2004iterative,howell2019altro}.
    
    During the ``forward rollout'' of these methods, the dynamics are simulated forward in time using updated control inputs: 
    \begin{equation} \label{eq:mlqr_control}
        u_k = \bar{u}_k - d_k - K_k \delta x_k.
    \end{equation}
    where $\bar{u}_k$ is the control value from the previous iteration, and $\delta x$ is
    computed using \eqref{eq:state_error}, with $x_k$ being the current state estimate
    and $\bar{x}_k$ the state from the previous iteration. 
    For more details on the ALTRO algorithm, which leverages ideas from both DDP and
    direct Newton methods, we refer the reader to~\cite{howell2019altro}.

    \subsection{Quaternion Cost Functions} \label{sec:cost_functions}
        In addition to the straight-forward modifications to the ALTRO algorithm itself, some care must be taken in designing cost functions that are well-suited to unit quaternions. We
        frequently minimize costs that penalize distance from a goal state, e.g. $\half
        (x-x_g)^T Q (x-x_g)$; However, na\"ive substraction of unit quaternions does not respect their group structure, and often results in undesired behavior. Instead, we have found the following cost function, which penalizes the geodesic
        distance between two unit quaternions \cite{Kuffner2004}, to work well in practice:
        \begin{equation} \label{eq:quat_geodesic}
            J_\text{geo} = (1-\abs{q_g^T q}) .
        \end{equation}
        Its gradient and Hessian are,
        \begin{align}
            \nabla J_\text{geo} &= \sign(q_d^T q) q_g^T G(q) \\
            \nabla^2 J_\text{geo} &= \sign(q_d^T q) I_3 q_g^T q ,
        \end{align}
        where $\sign$ denotes the signum function.
        
        % \subsubsection{Error Quadratic} \label{sec:error_quadratic}
        %     Rather than simple subtraction, we can use a quadratic function on the
        %     three-parameter error state \eqref{eq:state_error}:
        %     \begin{equation} \label{eq:error_quadratic}
        %         J_\text{err} = \half \phi^T Q \phi 
        %         = \half \left(\varphi^{-1}(\delta q)\right)^T Q 
        %                 \left(\varphi^{-1}(\delta q)\right).
        %     \end{equation}
        %     where $\delta q = L(q_g)^T q$, and $\phi = \varphi{\delta q}$. The gradient
        %     and Hessian of \eqref{eq:error_quadratic} are
        %     \begin{equation}
        %         \nabla J_\text{err }= \phi^T Q  D(\delta q)  G(\delta q)
        %     \end{equation}
        %     \begin{multline}
        %         \nabla^2 J_\text{err} = 
        %             G(\delta q)^T \! \left(
        %             D(\delta q)^T Q D(\delta q) + \nabla D \right) G(\delta q)  \\
        %             + I_3 (\phi^T Q  D(\delta q)) \delta q %\\
        %     \end{multline}
        %     where, for the Cayley map,
        %     \begin{equation}
        %         D(q) = \pdv{\varphi^{-1}}{q} = -\frac{1}{q_s^2}\begin{bmatrix}
        %             q_v \;\; & -\frac{1}{q_s} I_3
        %         \end{bmatrix}
        %     \end{equation}
        %     \begin{equation}
        %         \nabla D = \pdv{q}(D(q)^T Q \phi) 
        %         = -\frac{1}{q_s^2} \begin{bmatrix} 
        %             -2 \frac{q_v}{q_s}^T Q \phi & \phi^T Q \\
        %                            Q \phi & 0 \\
        %         \end{bmatrix}.
        %     \end{equation}

        % \subsubsection{Geodesic Distance} \label{sec:geodesic}

% \todo{If the geodesic distance works better on all the examples, I vote for leaving out the error quadratic stuff.}

\section{Experiments} \label{sec:experiments}
    In this section we present several trajectory optimization problems for systems that
    undergo large changes in attitude: an airplane barrel roll, a quadrotor flip, and a
    satellite with flexible solar panels that must slew to a new orientation while
    avoiding a keep-out zone.    
    All problems are run using ALTRO, first without any of the modifications presented in
    the current paper, analagous to the naive Newton's method in section \ref{sec:Wahbas}
    and labeled ``naive'', and then using the modifications listed in Sec.
    \ref{sec:trajopt} and the geodesic cost function described in Sec.
    \ref{sec:cost_functions}, labeled ``modified''. All cost functions were of the
    following form:
    \begin{align}
        \ell_\text{naive}(x, \bar{x}, Q) &= \half (x - \bar{x})^T Q (x - \bar{x}) \\
        \ell_\text{modified}(x, \bar{x}, Q) &= \half (x-\bar{x})^T \bar{Q} (x-\bar{x}) + w (1
            \pm \bar{q}^T q)
    \end{align}
    where $\bar{x}$ is the reference state and $\bar{Q} = \text{diag}(Q_r, \vec{0}_4,
    Q_v, Q_\omega)$, with $Q_r,Q_v,Q_\omega$ being the weights of $Q$ for position, and
    linear and angular velocity, respectively.
    
    Timing results are summarized in Table \ref{tab:timing_results}. All experiments were
    solved to a constraint satisfaction tolerance of $10^{-5}$ and discretized with a 3rd
    order Runge-Kutta integrator. All results were run on a desktop computer with an AMD
    Ryzen 2950x processor with 40 GB of RAM. Code for all experiments is available on
    \href{https://github.com/RoboticExplorationLab/PlanningWithAttitude}
    {GitHub\footnote{\url{https://github.com/RoboticExplorationLab/PlanningWithAttitude}}}.

    \begin{table}
        \centering
        \input{figures/timing_results.tex}
        \label{tab:timing_results}
        \caption{Trajectory Optimization Timing Results (naive/modified)}
    \end{table}
        
    \subsection{Airplane Barrel Roll}
% \todo{Reference \eqref{eq:rigid_body_dynamics} and then say that the forces and torques due to lift and drag are fit from wind tunnel data. Also, cite that paper.}

        A 180 degree barrel roll trajectory for a fixed-wing airplane was optimized. The
        airplane's dynamics model consists of the a simple rigid body as defined in
        Section \ref{sec:rigidbody_dynamics} with forces and torques due to lift and drag
        fit from wind tunnel data \cite{manchester2016udp}. The airplane was tasked to do
        a barrel roll by constraining the terminal state to upside-down (see Fig.
        \ref{fig:barrellroll}). To avoid issues with the double-cover and integration error,
        the following was used to enforce a terminal orientation to $\bar{q}$:
        \begin{equation}
            \frac{q_v}{\norm{q}} - \bar{q}_v
                \sign\left(\bar{q}^T \frac{q }{ \norm{q}}\right) = 0
        \end{equation}

        The solver was initialized with level flight trim
        conditions. The convergence of the different versions of ALTRO is compared in
        Fig. \ref{fig:c_max_convergence}. As expected, the modified version achieves
        better convergence and faster solve times compared to the na\"ive version since
        the expansions being provided to the algorithm more accurately capture the
        relationship between the attitude state and the goal and constraints. For this 
        relatively simple problem, we gained a modest 7\% improvement in runtime, despite
        the additional matrix multiplications when calculating the cost and constraint
        expansions.

        \begin{figure}[ht]
            \centering
            \includegraphics[width=\columnwidth]{figures/barrellroll.png}
            \caption{Barrel roll trajectory computed by ALTRO using a terminal cost to encourage an upside-down attitude.}
            \label{fig:barrellroll}
        \end{figure}

        \begin{figure}[ht]
            \centering
            \includegraphics[height=4cm,width=\columnwidth]{figures/c_max_convergence.tikz}
            \caption{Constraint satisfaction as a function of iteration when solving the barrel roll problem using ALTRO both with and without the modifications for optimizing unit quaternions.}
            \label{fig:c_max_convergence}
        \end{figure}

    \subsection{Quadrotor Flip}
        A 360 degree flip trajectory for a quadrotor was optimized with dynamics adapted
        from \cite{mellinger2012trajectory}. To encourage the flip, we specified a 
        ``waypoint'' cost function of the following form:
        \begin{multline}
                  \sum_{k \in \mathcal{N}} \ell(x_k, \hat{x}, \hat{Q}) 
                + \sum_{k \in \mathcal{W}} \ell(x_k, \bar{x}_k, Q_w) 
                + \half \sum_{k=1} u_k^T R u_k
        \end{multline}
        with $\mathcal{W} = \{45,51,55,75,101\}$, $\mathcal{N} = \{1:101\} \setminus
        \mathcal{W}$. The four intermediary ``waypoints'' were used to encourage the
        quadrotor to reach angles of \ang{90}, \ang{180}, \ang{270}, and \ang{360} around
        an approximately circular arc. The last waypoint was used to encourage the
        quadrotor to move towards the final goal. The quadrotor was constrained to stay
        above the floor and move to a goal state 2 meters away in the $+y$ direction. The
        solver was provided a dynamically infeasible initial trajectory that linearly
        interpolates between the initial and final states, rotating the quadrotor around
        the x-axis a full \ang{360}.

	    Figure \ref{fig:quad_flip} shows snapshots of the trajectory as generated using
	    ALTRO. The original version of ALTRO, even after significant tuning efforts, was
        not able to converge to the desired solution. 
	    This behavior is common and expected when attempting optimization that does not
	    properly account for the group structure of rotations. It is also worth noting
	    that this problem could not be solved using any three-parameter attitude
	    representation, since it passes through the singularities at $90\degree,
	    180\degree$, and $360\degree$ associated with Euler angles, Rodrigues parameters,
	    and Modified Rodrigues Parameters, respectively.

        \begin{figure}[ht]
            \centering
            \includegraphics[width=\columnwidth]{figures/quadflip.png}
            \caption{Snapshots of the quadrotor flip trajectory. The
                gree-colored quadrotors represent the state near t=0 s and the
                red-colored quadrotors represent the state near t=5.0 s
            }
            \label{fig:quad_flip}
        \end{figure}    

    \subsection{Satellite Attitude Keep-Out}
        % \todo{Let's add a little more detail here: How about saying the dynamics are \eqref{eq:rigid_body_dynamics} plus a few extra states to capture the bending modes. Also, let's just call the start tracker a camera or sensor.}
        A spacecraft with flexible appendages was tasked to perform a 150 degree slew maneuver while
        ensuring that a body-mounted camera did not point within 40 degrees ``keep-out zone'' around the sun vector. The spacecraft dynamics are presented in detail in~\cite{Tracy2020}, and are based
        on equation \eqref{eq:rigid_body_dynamics} with the addition of six states to account for three flexible modes. Control torques are generated by four reaction wheels.
        
        \todo{Kevin: add some info on cost function, initial guess (if any), etc.}
        
        We enforce the camera keep-out zone can with the following constraint,
        \begin{equation}
            \left(\inframe{W}{r_{sun}}\right)^T 
            \left(\toframe{W}{B}{A(q)} \, \inframe{B}{r_{cam}} \right) \leq \cos(40 ^\circ) ,
        \end{equation}
        where $^Br_{cam}$ is the camera line-of-sight unit vector in the body frame and $^Wr_{sun}$ is the unit vector pointing to the sun in the world frame. The attitudes that satisfy this constraint comprise a non-convex set, with the
        constraint itself being nonlinear in $q$.
        \begin{figure}[ht]
            \centering
            \includegraphics{figures/kevins_plots/attitude_slew_plot.tikz}
            \caption{Visualization of the flexible spacecraft slew with a keep-out zone. Attitude is parameterized with a Rodrigues parameter to visualize the trajectory in three dimensions. The constraint surface represents attitudes where the camera line-of-sight is within 40$^\circ$ of the sun. The unconstrained solution violates this constraint, while the constrained solution is able to avoid the keep out zone.}
            \label{fig:keepout}
        \end{figure}
        % \todo{Talk a little about the results in the plot here.}
        
        \todo{Kevin: looks like both versions of ALTRO worked fine on this problem, so we should probably not say all this group stuff. Maybe just comment on the timing results and try to offer an explanation.}
        
        ALTRO is able to reason about this nonlinear constraint, and account for the group
        structure present in the quaternion. From Figure \ref{fig:keepout} we can see that
        without the camera constraint present, the trajectory will pass through the keep-out
        zone, making the trajectory infeasible. With the keep-out zone constraint present, ALTRO
        is able to converge on a trajectory that performs the slew in an efficient manner, while
        keeping the camera sufficiently far from the sun. 

        The modifications didn't have a significant impact on runtime performance for this
        example. In our experience, the computational benefits of the proposed methodology are
        problem-dependent, especially for highly nonlinear systems. The following examples result
        in more dynamic and aerobatic behaviors, where the computational benefit of the proposed
        methodology is significant, including an example where the naive method failed to find a
        good solution.
    

\section{Conclusions} \label{sec:conclusion}
    We have presented a general, unified method for optimization-based planning and control for rigid-body
    systems with arbitrary attitude using standard linear algebra and vector calculus.
    We have demonstrated that the application of this methodology is straightforward and
    yields substantial improvements in the convergence of Newton-based methods (see Fig. 
    \ref{fig:wahba_convergence}), while also offering improvements for nonlinear constrained
    trajectory optimization for floating-base systems (see Table \ref{tab:timing_results}).
    
    \todo{This is a really nice pitch. Can we say something like this in the intro?}
    With the modifications presented, ALTRO can solve problems few other methods for
    trajectory optimization can. Many state-of-the-art methods, such as direct
    collocation or sequential convex programming, rely on commercial, proprietary, or
    general-purpose solvers whose internal numerics often are abstracted away from the
    user. By exploiting the unique structure of both the trajectory optimization problem
    and the rotation group, ALTRO will likely be able to solve more challenging problems
    with performance.

    The methods presented here can easily be leveraged to adapt other classes
    of gradient or Newton-based algorithms to exploit the structure of 3D rotations. Future
    work may include adaptation of methods for state estimation, localization, design, or 
    other methods for motion planning such as direct collocation. 
    
    Future work will focus on continued 
    refinement of ALTRO and performance improvements for use in real-time model-predictive control applications, as well as extensions to multi-body robotic
    systems, such as humanoids or quadrupeds, represented in
    ``maximal'' coordinates that include the 3D orientation of each body \cite{brudigam2020linear}. 

\section*{Acknowledgements}
This material is based upon work supported by the National Science Foundation Graduate
Research Fellowship Program under Grant No. DGE-1656518. Any opinions, findings, and
conclusions or recommendations expressed in this material are those of the author(s) and
do not necessarily reflect the views of the National Science Foundation

\todo{Add NASA acknowledgements (JPL + ECF)}


\printbibliography

\end{document}