
\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out if you need a4paper
\IEEEoverridecommandlockouts                              % This command is only needed if 
                                                          % you want to use the \thanks command
\overrideIEEEmargins                                      % Needed to meet printer requirements.


% Bibliography
\usepackage{biblatex}
\addbibresource{references.bib}

% Math
\usepackage{physics}
\usepackage{siunitx}
\sisetup{output-exponent-marker=\ensuremath{\mathrm{e}}}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{tensor}

% Optimization and Algorithms
\usepackage{optidef}
\usepackage{algorithmicx}
\usepackage{algorithm,algpseudocode}

% Formatting
\usepackage{xcolor}
\usepackage{bm}  % for bold symbols 
\usepackage{booktabs}  % better tables
\usepackage{pifont}  % for x mark
\usepackage{graphicx}
\usepackage{hyperref}

% Plotting
\usepackage{pgfplots}
\pgfplotsset{compat=1.15,
	legend style={font=\footnotesize},
}
\usepackage{tikzscale}
% \pgfplotsset{every axis plot post/.style={
%     very thick,
% }
% }

% Custom commands
\newcommand{\half}{\frac{1}{2}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{S}^3}
\newcommand{\skewmat}[1]{[#1]^\times}

\newcommand{\rmap}{\varphi}
\newcommand{\invrmap}{\varphi^{-1}}

\DeclareMathOperator{\sign}{sign}

\newcommand{\dR}{\delta \mathcal{R}}
\newcommand{\rot}{ \mathcal{R} }
\newcommand{\dq}{\delta q}
\newcommand{\q}{\textbf{q}}
\newcommand{\eq}{_\text{eq}}
\newcommand{\traj}[2][N]{#2_{0:{#1}}}
\newcommand{\pass}{{\color{green} \checkmark}}
\newcommand{\fail}{{\color{red} \ding{55}}}
\newcommand{\inframe}[2]{{}^{#1}\!#2}
\newcommand{\toframe}[3]{\inframe{#1}{#3}^{#2}}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}


\title{\LARGE \bf
Planning with Attitude
}

\author{Brian Jackson$^1$, Kevin Tracy$^1$, and Zachary Manchester$^1$%
    \thanks{
        $^1$Robotics Institute, 
        Carnegie Mellon University, 
        5000 Forbes Ave, Pittsburgh, PA, USA
    }
}

\begin{document}
\maketitle

\begin{abstract}
Planning trajectories for floating-base robotic systems that experience
large attitude changes is challenging due to the nontrivial group structure of 3D
rotations. This paper introduces a powerful and accessible approach for 
optimization-based planning on the space of rotations using only standard linear algebra and vector calculus. We demonstrate the effectiveness of the approach by adapting Newton's
method to solve the canonical Wahba's problem, and modifying the trajectory optimization solver ALTRO to plan directly on the space of unit 
quaternions, achieving superior convergence on problems involving significant changes 
in attitude.
%\keywords{trajectory optimization, motion planning, control, quaternions}

\end{abstract}

\section{INTRODUCTION}

    Many robotic systems---including quadrotors, airplanes, satellites, autonomous
    underwater vehicles, and quadrupeds---can perform arbitrarily large three-dimensional
    translations and rotations as part of their normal operation. While representing
    translations is straightforward and intuitive, effectively representing the
    nontrivial group structure of 3D rotations has been a topic of study for many
    decades. Although we can intuitively deduce that rotations are three-dimensional, a
    globally non-singular three-parameter representation of the space of rotations does
    not exist \cite{stuelpnagel1964parametrization}. As a result, when parameterizing
    rotations, we must either a) choose a three-parameter representation and deal with
    singularities and discontinuities, or b) choose a higher-dimensional representation and deal with
    constraints between the parameters. While simply representing attitude is nontrivial,
    generating and tracking motion plans for floating-base systems is an even more
    challenging problem.

    Early work on control problems involving the rotation group dates back to the 1970s,
    with extensions of linear control theory to spheres \cite{Brockett1973} and $SO(3)$
    \cite{Baillieul1978}. Effective attitude tracking controllers have been developed for
    satellites \cite{wie1985quaternion}, quadrotors
    \cite{Fresk2013,Liu2015,lee2010geometric,
    Johnson2005,watterson2020control,mellinger2011minimum}, and a 3D inverted pendulum
    \cite{Chaturvedi2009} using various methods for calculating three-parameter attitude
    errors.

    More recently, these ideas have been extended to trajectory generation
    \cite{Zefran1998}, sample-based motion planning \cite{Zefran1999,Kuffner2004}, and
    optimal control. Approaches to optimal control with attitude states include
    analytical methods applied to satellites \cite{Spindler1998}, discrete mechanics
    \cite{Kobilarov2011,Kobilarov2014, Lee2008}, a combination of sampling-based planning
    and constrained trajectory optimization for satellite formations \cite{Garcia2005,
    Aoude2008}, projection operators \cite{Saccon2013}, or more general theory for
    optimization on manifolds \cites{watterson2018trajectory}. Nearly all of these
    methods rely heavily on principles from differential geometry and Lie group theory;
    however, despite these works, many recent papers in the robotics community continue
    to naively apply standard methods for motion planning and control with no regard for the
    group structure of rigid body motion \cite{Alothman2016,deCrousaz2015,
    Williams2017,Geisert2016}.
    
    In this paper, we make a departure from previous approaches to geometric planning and 
    control that rely heavily on ideas and notation from differential geometry, 
    and instead use only basic mathematical tools from linear algebra and vector calculus that 
    should be familiar to most roboticists. In Sec. \ref{sec:Quaternion_Calculus} we introduce 
    an approach to quaternion differential calculus similar to \cite{Mandic2011,Xu2016}, but significantly simpler and more general, enabling straight-forward adaptation of 
    existing algorithms to systems with quaternion states. 
    For concreteness, we then apply our method to the canonical
    Wahba's problem~\cite{Wahba1965} in Sec. \ref{sec:Wahbas}, and demonstrate superior convergence to approaches that
    fail to properly account for the group structure. 
    In Sec. \ref{sec:trajopt} we extend these ideas to the problem of trajectory optimization,
    and detail modifications to ALTRO, a state-of-the-art constrained trajectory optimization
    solver, and demonstrate performance gains on several benchmark problems.
    %To our knowledge, there does not currently exist a solver that is capable of leveraging the unique Markovian structure of the fixed-horizon trajectory optimization problem while correctly accounting for the group structure of 3D rotations.
    In summary, our contributions include:

    \begin{itemize}
        \item A unified approach to quaternion differential calculus entirely based on standard linear algebra and vector calculus.
        \item Derivation of a Newton-based algorithm for nonlinear optimization directly on the space of unit quaternions using our notation.
        \item a fast and efficient solver for trajectory optimization problems with 
        attitude dynamics and nonlinear constraints that correctly accounts for the group
        structure of 3D rotations.
    \end{itemize}


\section{Background}

    We begin by defining some useful conventions and notation. 
    Attitude is defined as the rotation from the robot's body frame to the world frame.
    We also define gradients to be row vectors, that is, for 
        $f(x) : \R^n \to \R$, $\pdv{f}{x} \in \R^{1\times n}$.

    \subsection{Unit Quaternions} \label{sec:quaternions}
        We leverage the fact that quaternions are linear operators and that the space of
        quaternions $\mathbb{H}$ is isomorphic to $\R^4$ to explicitly
        represent---following the Hamilton convention---a quaternion $\q \in \mathbb{H}$
        as a standard vector $q \in \R^4 := [q_s \;\; q_v^T]^T$ where $q_s \in \R$ and
        $q_v \in \R^3$ are referred to as the scalar and vector parts of the quaternion,
        respectively. The space of unit quaternions, $\Q = \{q : \norm{q}_2 = 1\}$, is a 
        a double-cover of the rotation group $SO(3)$, since $q$ and $-q$ represent the same 
        rotation \cite{markley2014fundamentals}.
        
        Quaternion multiplication is defined as
        \begin{equation} \label{eq:quat_mult}
            \q_2 \otimes \q_1 = L(q_2) q_1 = R(q_1) q_2
        \end{equation}
        where $L(q)$ and $R(q)$ are orthonormal matrices defined as
        \begin{align}
            L(q) &:= \begin{bmatrix} 
                q_s \;\; & -q_v^T \\ 
                q_v \;\; & q_s I + \skewmat{q_v} 
            \end{bmatrix} 
            \label{eq:Lmult} \\
            %= \begin{bmatrix} q & G(q) \end{bmatrix} \label{eq:Lmult} \\
            R(q) &:=\begin{bmatrix} 
                q_s \;\; & -q_v^T \\ 
                q_v \;\; & q_s I - \skewmat{q_v} 
            \end{bmatrix} \label{eq:Rmult},
        \end{align}
        and $\skewmat{x}$ is the skew-symmetric matrix operator
        \begin{equation}
            \skewmat{x} := \begin{bmatrix} 
                0 & -x_3 & x_2 \\ 
                x_3 & 0 & -x_1\\ 
                -x_2 & x_1 & 0 
            \end{bmatrix}.
        \end{equation}
        
        The inverse of a unit quaternion $\q^{-1}$, giving the opposite rotation, is equal 
        to its conjugate $\q^*$, which is simply the same quaternion with a negated vector 
        part:
        \begin{equation} \label{eq:T}
            \q^* = T q := \begin{bmatrix} 
                1 & \\ 
                & -I_3 
            \end{bmatrix} q
        \end{equation}
        The following identities, which are easily derived from
        \eqref{eq:Lmult}--\eqref{eq:T}, are extremely useful:
        \begin{align}
            &L(Tq) = L(q)^T = L(q)^{-1} \\
            &R(Tq) = R(q)^T = R(q)^{-1} .
        \end{align}
        
        We will sometimes find it helpful to create a quaternion with zero scalar part from 
        a vector $r \in \R^3$. We denote this operation as,
        \begin{equation}
            \hat{r} = H r \equiv \begin{bmatrix} 0 \\ I_3 \end{bmatrix} r.
        \end{equation}
        Unit quaternions rotate a vector through the operation 
        $\hat{r}' = \q \otimes \hat{r} \otimes \q^*$. 
        This can be equivalently expressed using matrix multiplication as
        \begin{align} 
            r' &= H^T L(q) R(q)^T H r = A(q)r , \label{eq:quaternion_rotation}
        \end{align}
        where $A(q)$ is the rotation matrix in terms of the elements of the quaternion 
        \cite{kane1983spacecraftdynamics}.

    \subsection{Rigid Body Dynamics} \label{sec:rigidbody_dynamics}
        For clarity, we will restrict our attention to rigid bodies moving freely in 3D 
        space. That is, we consider systems with dynamics of the following form:
        \begin{equation} \label{eq:rigid_body_dynamics}
            x = \begin{bmatrix} r \\ R \\ v \\ \omega \end{bmatrix}, \quad 
            \dot{x} = \begin{bmatrix} 
                v \\ 
                \half \q \otimes \hat{\omega} = \half L(q) H \omega \\ 
                \frac{1}{m} \inframe{W}{F(x,u)} \\ 
                J^{-1}(\inframe{B}{\tau(x,u)} - \omega \times J \omega) 
            \end{bmatrix}
        \end{equation}
        where $x$ and $u$ are the state and control vectors, $r \in \R^3$ is the
        position, $\q \in \Q$ is the attitude, $v \in \R^3$ is the linear velocity, and
        $\omega \in \R^3$ is the angular velocity. $m \in \R$ is the mass, $J \in
        \R^{3\times3}$ is the inertia matrix, $\inframe{W}{F(x,u)} \in \R^3$ are the
        forces in the world frame, and $\inframe{B}{\tau(x,u)}$ are the moments in the
        body frame.

\section{Quaternion Differential Calculus} \label{sec:Quaternion_Calculus}
    We now present a simple but powerful method for taking derivatives of functions 
    involving quaternions based on the notation and linear algebraic operations outlined 
    in Sec. \ref{sec:quaternions}.
    
    \begin{figure}
        \centering
        \includegraphics[height=5cm]{figures/tangent_plane.tikz}
        \caption{
            When linearizing about a point $q$ on an sphere $\mathbb{S}^{n-1}$ in 
            n-dimensional space, the tangent space $T$ is a plane living in $\R^{n-1}$, 
            illustrated here with $n=3$. Therefore, when linearizing about a unit 
            quaternion $q \in \Q$, the space of differential rotations lives in $\R^3$.
        }
        \label{fig:tangent_plane}
    \end{figure}
        
        Derivatives consider the effect an infinitesimal perturbation to the input has on
        an infinitesimal perturbation to the output. For vector spaces, the composition
        of the perturbation with the nominal value is simple addition and the
        infinitesimal perturbation lives in the same space as the original vector. For
        unit quaternions, however, neither of these are true; instead, they compose
        according to \eqref{eq:quat_mult}, and infinitesimal unit quaternions are (to
        first order) confined to a 3-dimensional plane tangent to $\Q$ (see Fig.
        \ref{fig:tangent_plane}).

        The fact that differential unit quaternions are three-dimensional should make
        intuitive sense: Rotations are inherently three-dimensional and differential
        rotations should live in the same space as angular velocities, i.e. $\R^3$.
        
        There are many possible three-parameter representations for small rotations in
        the literature. Many authors use the exponential map \cite{Baillieul1978,
        Zefran1998, Lee2008, Saccon2013, Sola2017, Fan2016, watterson2018trajectory},
        while others have used the Cayley map (also known as Rodrigues parameters)
        \cite{Kobilarov2011, Kobilarov2014}, Modified Rodrigues Parameters (MRPs)
        \cite{Terzakis2018}, or the vector part of the quaternion \cite{Fresk2013}.
        We choose Rodrigues parameters \cite{markley2014fundamentals} because they are
        computationally efficient and do not inherit the sign ambiguity associated with
        unit quaternions. The mapping between a vector of Rodrigues parameters $\phi \in
        \R^3$ and a unit quaternion $q$ is known as the Cayley map: \begin{equation}
        \label{eq:cayley}
            q = \varphi(\phi) = \frac{1}{\sqrt{1 + \norm{\phi}^2}} \begin{bmatrix} 1 \\ \phi \end{bmatrix}.
        \end{equation}
        We will also make use of the inverse Cayley map:
        \begin{equation}
            \phi = \varphi^{-1}(q) = \frac{q_v}{q_s}.
        \end{equation}

    \subsection{Jacobian of Vector-Valued Functions}
        When taking derivatives with respect to quaternions, we must take into account
        both the composition rule and the nonlinear mapping between the space of unit
        quaternions and our chosen three-parameter error representation.

        Let $\phi \in \R^3$ be a differential rotation applied to a function with
        quaternion inputs $y = h(q): \Q \to \R^p$, such that
        \begin{equation} \label{eq:vector_function}
            y + \delta y = h(L(q) \varphi(\phi)) \approx h(q) +  \nabla h(q) \phi.
        \end{equation}
        We can calculate the Jacobian $\nabla h(q) \in \R^{p \times 3}$ by
        differentiating \eqref{eq:vector_function} with respect to $\phi$, evaluated at
        $\phi = 0$:
        \begin{equation} \label{eq:quat_gradient}
            \nabla h(q) = \pdv{h}{q} L(q) H := \pdv{h}{q} G(q) 
                        = \pdv{h}{q} \begin{bmatrix} 
                            -q_v^T \\ 
                            q_s I_3 + \skewmat{q_v}
                        \end{bmatrix}
        \end{equation}
        where $G(q) \in \R^{4 \times 3}$ is the \textit{attitude Jacobian}, which
        essentially becomes a ``conversion factor'' allowing us to apply results from
        standard vector calculus to the space of unit quaternions. This form is
        particularly useful in practice since $\pdv*{h}{q} \in \R^{p \times 4}$ can be
        obtained using finite differences or automatic differentiation.
        As an aside, although we have used Rodrigues parameters, $G(q)$ is actually the
        same (up to a constant scalar factor) for any choice of three-parameter attitude
        representation.

    \subsection{Hessian of Scalar-Valued Functions}
	    If the output of $h$ is a scalar ($p = 1$), then we can find its Hessian by
	    taking the Jacobian of \eqref{eq:quat_gradient} with respect to $\phi$ using the
        product rule, again evaluated at $\phi = 0$:

	    \begin{equation} \label{eq:quat_hessian}
            \nabla^2 h(q) = G(q)^T \pdv[2]{h}{q} G(q) + I_3 \pdv{h}{q}q,
	    \end{equation}
	    where the second term comes from the second derivative of $\varphi(\phi)$.
	    Similar to $G(q)$, this expression is the same (up to a constant scalar factor) for any
        choice of three-parameter attitude representation.
        
    \subsection{Jacobian of Quaternion-Valued Functions}
        We now consider the case of a function that maps unit quaternions to unit
        quaternions, $q' = f(q) : \Q \to \Q$. 
        % \todo{Let's make sure we're bing consistent with our usage of $\Q$ vs. $\mathbb{H}$.} 
        Here we must also consider the non-trivial
        effect of a differential rotation applied to the output, i.e.:
        \begin{equation} \label{eq:dqoutput}
            L(q') \varphi(\phi') = f(L(q)\varphi(\phi)) .
        \end{equation}
        Solving \eqref{eq:dqoutput} for $\phi'$ we find,
        \begin{equation} \label{eq:phiprime}
            \phi' = \varphi^{-1} \left( L(q')^T f(L(q)\varphi(\phi)) \right) \approx \nabla f(q) \, \phi.
        \end{equation}
        Finally, the desired Jacobian is obtained by taking the derivative of
        \eqref{eq:phiprime} with respect to $\phi$:
        \begin{equation} \label{eq:quat_jacobian}
            \nabla f(q) = H^T L(q')^T \pdv{f}{q} L(q) H = G(q')^T \pdv{f}{q} G(q).
        \end{equation}
        The leading $G(q')^T$ comes from the fact that as $\phi' \to 0$, $L(q') f(q) \to
        I_q$, where $I_q$ is the quaternion identity. Once again, \eqref{eq:quat_jacobian} holds (up to a constant) for any three-parameter attitude representation.
        
        %Differentiating through the inverse map, evaluated at the quaternion identity, we find that $\pdv*{\varphi^{-1}}{q}\to H^T$ for any three-parameter attitude representation.


\section{Modifying Newton's Method} \label{sec:Wahbas}

% \todo{I would re-work this section to only talk about the details of doing it the ``correct'' way (i.e. consistent with the previous section). Then just call the standard version a ``naive Newton method in which the quaternion is re-normalized at each step'' and don't bother writing any of the mathematical details for that version. I think it will get confusing if you mix derivative types/notation.}

    Newton's method uses derivative information about a function to iteratively
    approximate its roots. For unconstrained systems, this method is highly effective,
    and can exhibit quadratic convergence. For constrained systems, the updated parameter
    can be projected back onto the feasible set at each iteration, but without the same
    convergence guarantees. For the constraints on $SO(3)$, Newton's method struggles to
    converge past a certain threshold due to this projection. By leveraging the
    quaternion calculus introduced, Newton's method can be modified to implicitly account
    for these constraints. To demonstrate this, we will examine Wahba's Problem. In 1965,
    Grace Wahba proposed the criterion for a least squares estimate of a spacecraft's
    attitude from vector measurements \cite{Wahba1965, markley2014fundamentals}. We will
    solve this problem using a modified version of Newton's method that exploits the true
    group structure of $SO(3)$ using the quaternion calculus presented here.
    

    \subsection{Methodology}
% \todo{Let's keep our notation and language consistent for body vs. inertial frames. I propose ``body'' (B) and ``inertial'' or ``world'' (W), which is the standard in robotics.}
    Given known vectors in some world frame, $\inframe{W}{w_i}$, and measurements of these
    vectors in some body fixed frame, $\inframe{B}{v_i}$, our goal is to determine the relative
    rotation from the body to world frame $\toframe{W}{B}{A(q)}$, expressed as a quaternion. We
    can define Wahba's loss function as the following: 
    \begin{equation} \label{eq:wahba_loss}
        L = \sum_i \norm{\inframe{W}{w_i} - \toframe{W}{B}{A(q)} \,\, \inframe{B}{v_i} }_2^2 
           = \norm{r_i(q)}_2^2 
    \end{equation} 
    % \todo{Let's leave the $w_i$ off for clarity since you're not using it later.}
    where $r_i(q)$ is the residual vector.

    We can solve for $\toframe{W}{B}{q}$ using a nonlinear least squares method minimizing
    Wahba's loss function:
    \begin{mini*}
        {q}{ \norm{r(q)}_2^2 }{}{}
        \addConstraint { q\in \Q.}
    \end{mini*}
    % \todo{This should be $q \in \Q$ here, since unit quaternions are not isomorphic to $SO(3)$ (rotation matrices).}
    Following the typical approach for Newton's method, we minimize \eqref{eq:wahba_loss}
    by setting the gradient to zero:
    \begin{equation} \label{eq:newton_foc}
        \begin{aligned}
            \pdv{L}{q}^T &= \sum_i \pdv{r(q)}{q}^T r_i(q) := \bar{J}^T r(q) = 0 \\
              &= \sum_i (-2 H^T R(q)^T R({}^B \hat{v}_i)^T r(q).
        \end{aligned}
    \end{equation}
    which can be obtained from the chain rule and \eqref{eq:quaternion_rotation}. 

    % Treating $q$ as a vector in $\R^4$, we obtain a solution to \eqref{eq:newton_foc}
    % using the Moore-Penrose pseudoinverse, $\delta q = (J^T J)^{-1} J^T$, and our
    % next candidate quaternion via simple addition, $q_{k+1} = q_k + \delta q$. Since
    % $q_{k+1}$ will no longer be unit norm, we project it back on the unit sphere via
    % the projection operator $\Pi(q) = q / \norm{q}$. This ``projected'' Newton approach
    % is summarized in Algorithm \ref{alg:pgn}.

    % \begin{algorithm} 
    % 	\begin{algorithmic}[1]
    % 		\caption{Projected Gauss-Newton Method}\label{alg:pgn}
    % 		\State $k = 0$
    % 		\While{significant progress}
    % 		    \State $J = \pdv{r(q_k)}{ \partial q}$ 
    % 		    \State $ \delta q = -(J^TJ)^{-1}J^T r(q_k)$ 
    % 		  %  \State $q_{n+1} = \text{normalize}(q_n + q_{step})$ 
    % 		  \State $q_{k+1} = \Pi_{SO(3)}(q_k + \delta q)$ 
    % 		    \State $k = k + 1$
    % 		\EndWhile
    % 	\end{algorithmic}
    % \end{algorithm}
    
    Applying the methodology from the previous section, we actually want to minimize 
    \eqref{eq:wahba_loss} with respect to a differential rotation $\phi$, which 
    we do by simply ``correcting'' our Jacobian $\bar{J}$ using 
    \eqref{eq:quat_jacobian}:
    \begin{equation} 
        {J} = \pdv{r(\mathbf{q} \otimes \varphi(\phi))}{\phi} = \pdv{r(q)}{q} G(q).
    \end{equation}
    We then use this to obtain our Newton step by using the Moore-Penrose psuedoinverse:
    $\phi = ({J}^T {J})^{-1} {J}^T$. To obtain our next iterate, we ``add'' the step
    using the correct notion of composition for the group: $\q_{k+1} = \q_k \otimes
    \varphi(\phi)$. This ``multiplicative'' Newton algorithm is summarized in Algorithm
    \ref{alg:mgn}.

    \begin{algorithm} 
    	\begin{algorithmic}[1]
    		\caption{Multiplicative Gauss-Newton Method}\label{alg:mgn}
    		\State $k = 0$
    		\While{significant progress}
    		    \State ${J} = \pdv{r(q_k)}{q} G(q_k)$ \Comment{quaternion adjusted Jacobian}
    		    \State $ \phi = -({J}^T {J})^{-1} {J}^T r(q_k)$ 
    		    \State $\q_{k+1} = \q_k \otimes \varphi(\phi)$ \Comment{apply step multiplicatively}
    		    \State $k = k + 1$
    		\EndWhile
    	\end{algorithmic}
    \end{algorithm}



    \subsection{Results}
    We compared this modified Newton's method with a na\"ive Newton's method where the
    quaternion is simply re-normalized at every iteration. As illustrated in Figure
    \ref{fig:wahba_convergence}, it is clear that the naive original method makes progress
    initially, but fails to exhibit the quadratic convergence typical of a Newton method.
    By optimizing directly in the space of unit quaternions, the modified method is able
    to achieve the expected quadratic convergence. It should also be clear from the 
    previous section that the adaptations to the original Newton method are simple and
    straightforward, highlighting both the effectiveness and value of the proposed
    approach.
    \begin{figure}

        \centering
        \includegraphics[width=\columnwidth, height=5cm]{figures/wahba_convergence.tikz}
        \caption{Convergence comparison for Wahba's problem. By performing Newton's method
        on the error quaternion and applying the result to the full quaternion we achieve
        quadratic convergence, whereas the more na\"ive approach doesn't converge to zero
        error. The angle error is calculated relative to the true analytical solution obtained
        via an SVD decomposition.}
        \label{fig:wahba_convergence}
    \end{figure}
    % \begin{figure}[H]
    %     \centering
    %     \includegraphics[width=\columnwidth, height=5cm]{figures/kevins_plots/convergence_plot.tikz}
    %     \caption{Convergence comparison for Wahba's problem. By performing Newton's method
    %     on the error quaternion and applying the result to the full quaternion we achieve
    %     quadratic convergence, whereas the more na\"ive approach doesn't converge to zero
    %     error.}
    %     \label{fig:wahba_convergence}
    % \end{figure}

\section{Trajectory Optimization on $\R^n \times SO(3)$} \label{sec:trajopt}
    Here we outline the modifications to the ALTRO solver \cite{howell2019altro}, to
    solve trajectory optimization problems for rigid bodies, which extends easily to
    arbitrary systems whose state is in $\R^n \times SO(3)$. %ALTRO is an efficient solver for constrained nonlinear optimization problems that uses iterative LQR (iLQR) with an augmented Lagrangian framework.

    We consider trajectory optimization problems of the form,
    \begin{mini}[2]
        {x_{0:N},u_{0:N-1}}{\ell_f(x_N) + \sum_{k=0}^{N-1} \ell_k(x_k,u_k) }{}{}
        \addConstraint{x_{k+1} = f(x_k,u_k)}
        \addConstraint{g_k(x_k,u_k)}{\leq 0}
        \addConstraint{h_k(x_k,u_k)}{=0}
        \label{discrete_trajopt},
    \end{mini}
    where $x$ and $u$ are the state and control vectors as described in Sec. \ref{sec:rigidbody_dynamics},
    $f$ are the dynamics as defined in \eqref{eq:rigid_body_dynamics}, $\ell_k$ is a general
    nonlinear cost function at a single time step,
    $N$ is the number of time steps, and $g_k$, $h_k$ are general nonlinear inequality and 
    equality constraints.

    Like most gradient or Newton-based methods for optimization, ALTRO approximates the
    nonlinear functions $f, \ell, g,$ and $h$ with their first or second-order Taylor
    series expansions. Leveraging the methods from Sec: \ref{sec:Quaternion_Calculus}, we
    adapt the algorithm to optimize directly on the error state $\delta x \in \R^{12}$.

    We begin by linearizing the dynamics about the reference trajectory using
    \eqref{eq:quat_jacobian}. Our linearized error dynamics become
    \begin{equation} \label{eq:linearized_dynamics}
        \delta x_{k+1} = A_k \delta x_k + B_k \delta u_k 
    \end{equation}
    where \begin{equation}
        \begin{aligned}
            A_k = E(\bar{x}_{k+1})^T \pdv{f}{x}|_{\bar{x}_k,\bar{u}_k} E(\bar{x}_k), \\
            B_k = E(\bar{x}_{k+1})^T \pdv{f}{u}|_{\bar{x}_k,\bar{u}_k},
        \end{aligned}
    \end{equation}
    and $\delta x_k \in \R^{12}$ and $E(x_k) \in \R^{12 \times 13}$ are the state error and state-error Jacobian, respectively:
    \begin{equation} \label{eq:state_error}
        \setlength\arraycolsep{1pt}
        \delta x_k = \begin{bmatrix} 
            r_k - \bar{r}_k \\ \varphi^{-1}(\bar{\q}_k^{-1} \otimes \q_k) \\ v_k - \bar{v}_k \\ \omega_k - \bar{\omega}_k 
        \end{bmatrix}\!, \;
        E(x) = \begin{bmatrix}
            I_3 & & & \\
            & G(q) & & \\
            & & I_3 & \\
            & & & I_3 \\
        \end{bmatrix}\!.
    \end{equation}
    
    By applying \eqref{eq:quat_gradient} and \eqref{eq:quat_hessian} to our nonlinear
    cost functions $\ell$ and \eqref{eq:quat_jacobian} to the nonlinear constraint
    functions $g_k$ and $h_k$, we can calculate the second-order expansion of the cost 
    function:
    \begin{multline}
        \delta \ell(x,u) \approx  \half \delta x^T \ell_{xx} \delta x
            + \half \delta u^T \ell_{uu} \delta u + \delta_u^T \ell_{ux} \delta u \\
            + \ell_x^T \delta x^T + \ell_u^T \delta u.
    \end{multline}
    % \todo{I think you can safely leave out any references to the augmented Lagrangian,
    % etc. and just talk about the cost function.}
    % \begin{equation}
    %     \mathcal{L}_A = \mathcal{L}_N(x_N,\lambda_N,\mu_N) + 
    %         \sum_{k=0}^{N-1} \mathcal{L}_k(x_k,u_k,\lambda_k,\mu_k)
    % \end{equation}
    % where
    % \begin{equation}
    %     \mathcal{L}_k(x,u,\lambda,\mu) = \ell(x,u) + 
    %         (\lambda + \half I_\mu c(x,u))^T c(x,u),
    % \end{equation}
    % with $c(x,u)$ being the concatenation of the constraints $f,g$, and $h$ at a given time step,
    % and $I_\mu$ the penalty matrix.

    With this expansion, we calculate the expansion of the ``action-value function'' $Q(x,u)$
    as normal, including the extra terms from the augmented Lagrangian cost:
    \begin{align}
        Q_{xx} &= \ell_{xx} + A_{k}^T P_{k+1} A_{k} \label{Qxx_exp}\\
        Q_{uu} &= \ell_{uu} + B_{k}^T P_{k+1} B_{k} \label{Quu_exp}\\
        Q_{ux} &= \ell_{ux} + B_{k}^T P_{k+1} A_{k} \label{Qux_exp}\\
        Q_x &= \ell_x  + A_{k}^T p_{k+1} \label{Qx_exp}\\
        Q_u &= \ell_u + B_{k}^T p_{k+1} \label{Qu_exp},
    \end{align}
    from which we can calculate the quadratic expansion of the cost-to-go 
    $P_k \in \R^{12 \times 12}$, $p_k \in \R^{12}$, and optimal linearized feedback gains 
    $K_k \in \R^{m \times 12}$ and $d_k \in \R^m$ by starting at the terminal state and
    resursing backward in time along the trajectory during the ``backward pass'' of the iLQR
    algorithm. During the ``forward pass'', the dynamics are simulated forward in time using
    the feedback gains computed during the backward pass. At each time step, the control is 
    calculated using the linear feedback controller: 
    \begin{equation} \label{eq:mlqr_control}
        u_k = K_k \delta x_k + \bar{u}_k.
    \end{equation}
    where $\bar{u}_k$ is the control value from the previous iteration, and $\delta x$ is
    computed using \eqref{eq:state_error}, with $x_k$ being the current state estimate
    and $\bar{x}_k$ the state from the previous iteration. The rest of the algorithm is
    left unchanged. For more details on the ALTRO algorithm, the reader is encouraged to
    refer to the original paper \cite{howell2019altro}.

    \subsection{Quaternion Cost Functions} \label{sec:cost_functions}
        In addition to the straight-forward modifications to the ALTRO algorithm itself,
        we need to carefully consider the types of cost functions we minimize. We
        frequently minimize costs that penalize distance from a goal state, e.g. $\half
        (x-x_g)^T Q (x-x_g)$; However, na\"ive substraction of unit quaternions is
        ill-defined. We propose the following cost function which penalizes the geodesic
        distance between two unit quaternions \cite{Kuffner2004}, which we have found to
        work well in practice. For sake of clarity and space, we only consider the costs
        on the quaternion variables: costs on the other states and the control variables
        remain unaffected.

        \begin{equation} \label{eq:quat_geodesic}
            J_\text{geo} = (1-\abs{q_g^T q}) ,
        \end{equation}
        whose gradient and Hessian are,
        \begin{align}
            \nabla J_\text{geo} &= \sign(q_d^T q) q_g^T G(q) \\
            \nabla^2 J_\text{geo} &= \sign(q_d^T q) I_3 q_g^T q ,
        \end{align}
        where $\sign$ denotes the signum function.
        
        % \subsubsection{Error Quadratic} \label{sec:error_quadratic}
        %     Rather than simple subtraction, we can use a quadratic function on the
        %     three-parameter error state \eqref{eq:state_error}:
        %     \begin{equation} \label{eq:error_quadratic}
        %         J_\text{err} = \half \phi^T Q \phi 
        %         = \half \left(\varphi^{-1}(\delta q)\right)^T Q 
        %                 \left(\varphi^{-1}(\delta q)\right).
        %     \end{equation}
        %     where $\delta q = L(q_g)^T q$, and $\phi = \varphi{\delta q}$. The gradient
        %     and Hessian of \eqref{eq:error_quadratic} are
        %     \begin{equation}
        %         \nabla J_\text{err }= \phi^T Q  D(\delta q)  G(\delta q)
        %     \end{equation}
        %     \begin{multline}
        %         \nabla^2 J_\text{err} = 
        %             G(\delta q)^T \! \left(
        %             D(\delta q)^T Q D(\delta q) + \nabla D \right) G(\delta q)  \\
        %             + I_3 (\phi^T Q  D(\delta q)) \delta q %\\
        %     \end{multline}
        %     where, for the Cayley map,
        %     \begin{equation}
        %         D(q) = \pdv{\varphi^{-1}}{q} = -\frac{1}{q_s^2}\begin{bmatrix}
        %             q_v \;\; & -\frac{1}{q_s} I_3
        %         \end{bmatrix}
        %     \end{equation}
        %     \begin{equation}
        %         \nabla D = \pdv{q}(D(q)^T Q \phi) 
        %         = -\frac{1}{q_s^2} \begin{bmatrix} 
        %             -2 \frac{q_v}{q_s}^T Q \phi & \phi^T Q \\
        %                            Q \phi & 0 \\
        %         \end{bmatrix}.
        %     \end{equation}

        % \subsubsection{Geodesic Distance} \label{sec:geodesic}

% \todo{If the geodesic distance works better on all the examples, I vote for leaving out the error quadratic stuff.}

\section{Experiments} \label{sec:experiments}
    In this section we present several trajectory optimization problems for systems that
    undergo large changes in attitude: an airplane barrel roll, a quadrotor flip, and a
    satellite with flexible solar panels that must slew to a new orientation while
    avoiding a keep-out zone. All results were run on a desktop computer with an AMD
    Ryzen 2950x processor with 40 GB of RAM. All problems are run using ALTRO, first
    without any of the modifications presented in the current paper, analagous to the
    naive Newton's method in section \ref{sec:Wahbas} and labeled ``naive'', and then
    using the modifications listed in Sec. \ref{sec:trajopt} and the geodesic cost
    function described in Sec. \ref{sec:cost_functions}, labeled ``modified''. Timing
    results are summarized in Table \ref{tab:timing_results}. All experiments were solved
    to a constraint satisfaction tolerance of $10^{-5}$ and discretized with a 4th order
    Runge-Kutta integrator. Code for all experiments is available on
    \href{https://github.com/RoboticExplorationLab/PlanningWithAttitude}
    {GitHub\footnote{\url{https://github.com/RoboticExplorationLab/PlanningWithAttitude}}}.

    \begin{table}
        \centering
        \input{figures/timing_results.tex}
        \label{tab:timing_results}
        \caption{Trajectory Optimization Timing Results (naive/modified)}
    \end{table}
        
    \subsection{Satellite Attitude Keep-Out}
        % \todo{Let's add a little more detail here: How about saying the dynamics are \eqref{eq:rigid_body_dynamics} plus a few extra states to capture the bending modes. Also, let's just call the start tracker a camera or sensor.}
        A spacecraft with flexible appendages must perform a 150 degree slew while
        ensuring that a body-mounted camera does not cross within 40 degrees of the sun.
        The attitudes that result in the camera pointing too close to the sun will be
        referred to as a keep-out zone. The flexible body spacecraft dynamics are based
        on equation \eqref{eq:rigid_body_dynamics}, with the addition of four reaction
        wheels, and the three largest flexible modes \cite{Tracy2020}. In order to ensure
        no damage to the camera, we must formulate a constraint that guarantees that the
        camera line-of-sight body-fixed vector ($^Br_{cam}$) does not look within 40
        degrees of the world-fixed sun vector ($^Wr_{sun}$). This angle constraint can be
        represented as a dot product between the two vectors expressed in the world
        frame:
        % \todo{Let's use standard matrix notation here rather than the angle brackets, and let's also write the rotation correctly using $A(q)$ like in the other sections.}
        \begin{equation}
            \left(\inframe{W}{r_{sun}}\right)^T 
            \left(\toframe{W}{B}{A(q)} \, \inframe{B}{r_{cam}} \right) \leq \cos(40 ^\circ).
        \end{equation}
        The attitudes that satisfy this constraint comprise a non-convex set, with the
        constraint itself being nonlinear in the attitude quaternion.
        \begin{figure}[H]
            \centering
            \includegraphics{figures/kevins_plots/attitude_slew_plot.tikz}
            \caption{Visualization of the flexible spacecraft slew with a keep-out zone. Attitude is parameterized with a Rodrigues parameter to visualize the trajectory in three dimensions. The constraint surface represents attitudes where the camera line-of-sight is within 40$^\circ$ of the sun. The unconstrained solution violates this constraint, while the constrained solution is able to avoid the keep out zone.}
            \label{fig:keepout}
        \end{figure}
        % \todo{Talk a little about the results in the plot here.}
        ALTRO is able to reason about this nonlinear constraint, and account for the group
        structure present in the quaternion. From Figure \ref{fig:keepout} we can see that
        without the camera constraint present, the trajectory will pass through the keep-out
        zone, making the trajectory infeasible. With the keep-out zone constraint present, ALTRO
        is able to converge on a trajectory that performs the slew in an efficient manner, while
        keeping the camera sufficiently far from the sun. 

        The modifications didn't have a significant impact on runtime performance for this
        example. In our experience, the computational benefits of the proposed methodology are
        problem-dependent, especially for highly nonlinear systems. The following examples result
        in more dynamic and aerobatic behaviors, where the computational benefit of the proposed
        methodology is significant, including an example where the naive method failed to find a
        good solution.

    \subsection{Airplane Barrel Roll}
% \todo{Reference \eqref{eq:rigid_body_dynamics} and then say that the forces and torques due to lift and drag are fit from wind tunnel data. Also, cite that paper.}

        Our airplane model is a simple rigid body as defined in Section
        \ref{sec:rigidbody_dynamics} with forces and torques due to lift and drag fit
        from wind tunnel data \cite{manchester2016udp}. The airplane was tasked to do a
        barrell roll by setting a high terminal cost for being upside-down, see Fig.
        \ref{fig:barrellroll}. The solver is initialized with level flight trim
        conditions. The convergence of the different versions of ALTRO is compared in
        Fig. \ref{fig:c_max_convergence}. As expected, the modified version achieves
        better convergence and faster solve times compared to the na\"ive version since
        the expansions being provided to the algorithm more accurately capture the
        relationship between the attitude state and the goal and constraints.

		% \todo{If we're not going to plot it and actually do an experimental comparison, I vote for leaving this stuff out.}
        % We also compared the ``error quadratic'' cost function described in Section
        % \ref{sec:error_quadratic} to the geodesic cost function in Section
        % \ref{sec:geodesic}. The geodesic cost was more efficient, both in term of
        % iterations and computation time, taking only 36 iterations and 1.8 ms/iteration
        % vs 76 iterations and 7.6 ms/iteration for the error quadratic. Not only is the
        % geodesic cost function much cheaper to compute, it also converges much faster
        % than the error quadratic cost function. This could be due to the strong nonlinearities
        % introduced when computing the quaternion error, making it more difficult to
        % optimize.
        
        \begin{figure}[ht]
            \centering
            \includegraphics[width=\columnwidth]{figures/barrellroll.png}
            \caption{Barrel roll trajectory computed by iterative MLQR using a terminal cost to encourage an upside-down attitude.}
            \label{fig:barrellroll}
        \end{figure}

        \begin{figure}[ht]
            \centering
            \includegraphics[height=4cm,width=\columnwidth]{figures/c_max_convergence.tikz}
            \caption{Constraint convergence when solving the barrel roll problem. Compares 
            the convergence of the original version of ALTRO versus the new, modified version
            that optimizing on the error state.}
            \label{fig:c_max_convergence}
        \end{figure}

    \subsection{Quadrotor Flip}
        We optimized a 360 degree flip trajectory for a quadrotor with dynamics adapated
        from \cite{mellinger2012trajectory} using the modified version of ALTRO. Four
        intermediary ``keyframes'' were used to encourage the quadrotor to be at angles
        of \ang{90}, \ang{180}, \ang{270}, and \ang{360} around an approximately circular
        arc. The quadrotor was constrained to stay above the floor and move to a goal
        state 2 meters away in the $+y$ direction. The solver was initialized with a
        dynamically infeasible trajectory that linearly interpolates between the initial
        and final states, rotating the quad around the x-axis a full \ang{360}.

	    Figure \ref{fig:quad_flip} shows snapshots of the trajectory as generated using
	    ALTRO. The original version of ALTRO, even after significant tuning efforts,
	    was not able to converge to the desired solution.
	    %It instead got halfway and then ``unwound'' 360 degrees and then continued rotating to the final orientation.
	    This behavior is common and expected when attempting optimization that does not
	    properly account for the group structure of rotations. It is also worth noting
	    that this problem could not be solved using any three-parameter attitude
	    representation, since it passes through the singularities at $90\degree,
	    180\degree$, and $360\degree$ associated with Euler angles, Rodrigues parameters, and
	    Modified Rodrigues Parameters, respectively.

        \begin{figure}[t]
            \centering
            \includegraphics[width=\columnwidth]{figures/quadflip.png}
            \caption{Snapshots of the quadrotor flip trajectory. The
                gree-colored quadrotors represent the state near t=0 s and the
                red-colored quadrotors represent the state near t=5.0 s
            }
            \label{fig:quad_flip}
        \end{figure}    
    

\section{Conclusions} \label{sec:conclusion}
    We have presented a general, unified method for optimization-based planning and control for rigid-body
    systems with arbitrary attitude using standard linear algebra and vector calculus.
    We have demonstrated that the application of this methodology is straightforward and
    yields substantial improvements in the convergence of Newton-based methods (see Fig. 
    \ref{fig:wahba_convergence}), while also offering improvements for nonlinear constrained
    trajectory optimization for floating-base systems (see Table \ref{tab:timing_results}).
    
    With the modifications presented, ALTRO can solve problems few other methods for
    trajectory optimization can. Many state-of-the-art methods, such as direct
    collocation or sequential convex programming, rely on commercial, proprietary, or
    general-purpose solvers whose internal numerics often are abstracted away from the
    user. By exploiting the unique structure of both the trajectory optimization problem
    and the rotation group, ALTRO will likely be able to solve more challenging problems
    with performance.

    The methods presented here can easily be leveraged to adapt other classes
    of gradient or Newton-based algorithms to exploit the structure of 3D rotations. Future
    work may include adaptation of methods for state estimation, localization, design, or 
    other methods for motion planning such as direct collocation. 
    
    Future work will focus on continued 
    refinement of ALTRO and performance improvements for use in real-time model-predictive control applications, as well as extensions to multi-body robotic
    systems, such as humanoids or quadrupeds, represented in
    ``maximal'' coordinates that include the 3D orientation of each body \cite{brudigam2020linear}. 

\paragraph*{Acknowledgements}
This material is based upon work supported by the National Science Foundation Graduate
Research Fellowship Program under Grant No. DGE-1656518. Any opinions, findings, and
conclusions or recommendations expressed in this material are those of the author(s) and
do not necessarily reflect the views of the National Science Foundation

\todo{Add NASA acknowledgements (JPL + ECF)}


\printbibliography

\end{document}